(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.tf_converter = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],2:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],3:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],4:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],5:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],6:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],7:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],8:[function(require,module,exports){
// minimal library entry point.

"use strict";
module.exports = require("./src/index-minimal");

},{"./src/index-minimal":9}],9:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Configure serialization
protobuf.Writer._configure(protobuf.BufferWriter);
configure();

},{"./reader":10,"./reader_buffer":11,"./roots":12,"./rpc":13,"./util/minimal":16,"./writer":17,"./writer_buffer":18}],10:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = util.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            do { // eslint-disable-line no-constant-condition
                if ((wireType = this.uint32() & 7) === 4)
                    break;
                this.skipType(wireType);
            } while (true);
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":16}],11:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

},{"./reader":10,"./util/minimal":16}],12:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],13:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":14}],14:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":16}],15:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":16}],16:[function(require,module,exports){
(function (global){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ global.dcodeIO && /* istanbul ignore next */ global.dcodeIO.Long || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./longbits":15,"@protobufjs/aspromise":1,"@protobufjs/base64":2,"@protobufjs/eventemitter":3,"@protobufjs/float":4,"@protobufjs/inquire":5,"@protobufjs/pool":6,"@protobufjs/utf8":7}],17:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};

},{"./util/minimal":16}],18:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

var Buffer = util.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

},{"./util/minimal":16,"./writer":17}],19:[function(require,module,exports){
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.tensorflow = (function() {

    /**
     * Namespace tensorflow.
     * @exports tensorflow
     * @namespace
     */
    var tensorflow = {};

    tensorflow.Any = (function() {

        /**
         * Properties of an Any.
         * @memberof tensorflow
         * @interface IAny
         * @property {string|null} [typeUrl] Any typeUrl
         * @property {Uint8Array|null} [value] Any value
         */

        /**
         * Constructs a new Any.
         * @memberof tensorflow
         * @classdesc Represents an Any.
         * @implements IAny
         * @constructor
         * @param {tensorflow.IAny=} [properties] Properties to set
         */
        function Any(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Any typeUrl.
         * @member {string} typeUrl
         * @memberof tensorflow.Any
         * @instance
         */
        Any.prototype.typeUrl = "";

        /**
         * Any value.
         * @member {Uint8Array} value
         * @memberof tensorflow.Any
         * @instance
         */
        Any.prototype.value = $util.newBuffer([]);

        /**
         * Creates a new Any instance using the specified properties.
         * @function create
         * @memberof tensorflow.Any
         * @static
         * @param {tensorflow.IAny=} [properties] Properties to set
         * @returns {tensorflow.Any} Any instance
         */
        Any.create = function create(properties) {
            return new Any(properties);
        };

        /**
         * Encodes the specified Any message. Does not implicitly {@link tensorflow.Any.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.Any
         * @static
         * @param {tensorflow.IAny} message Any message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Any.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeUrl);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
            return writer;
        };

        /**
         * Encodes the specified Any message, length delimited. Does not implicitly {@link tensorflow.Any.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.Any
         * @static
         * @param {tensorflow.IAny} message Any message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Any.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Any message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.Any
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.Any} Any
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Any.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.Any();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeUrl = reader.string();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Any message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.Any
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.Any} Any
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Any.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Any message.
         * @function verify
         * @memberof tensorflow.Any
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Any.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                if (!$util.isString(message.typeUrl))
                    return "typeUrl: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                    return "value: buffer expected";
            return null;
        };

        /**
         * Creates an Any message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.Any
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.Any} Any
         */
        Any.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.Any)
                return object;
            var message = new $root.tensorflow.Any();
            if (object.typeUrl != null)
                message.typeUrl = String(object.typeUrl);
            if (object.value != null)
                if (typeof object.value === "string")
                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                else if (object.value.length)
                    message.value = object.value;
            return message;
        };

        /**
         * Creates a plain object from an Any message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.Any
         * @static
         * @param {tensorflow.Any} message Any
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Any.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeUrl = "";
                object.value = options.bytes === String ? "" : [];
            }
            if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                object.typeUrl = message.typeUrl;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
            return object;
        };

        /**
         * Converts this Any to JSON.
         * @function toJSON
         * @memberof tensorflow.Any
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Any.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Any;
    })();

    /**
     * DataType enum.
     * @name tensorflow.DataType
     * @enum {string}
     * @property {number} DT_INVALID=0 DT_INVALID value
     * @property {number} DT_FLOAT=1 DT_FLOAT value
     * @property {number} DT_DOUBLE=2 DT_DOUBLE value
     * @property {number} DT_INT32=3 DT_INT32 value
     * @property {number} DT_UINT8=4 DT_UINT8 value
     * @property {number} DT_INT16=5 DT_INT16 value
     * @property {number} DT_INT8=6 DT_INT8 value
     * @property {number} DT_STRING=7 DT_STRING value
     * @property {number} DT_COMPLEX64=8 DT_COMPLEX64 value
     * @property {number} DT_INT64=9 DT_INT64 value
     * @property {number} DT_BOOL=10 DT_BOOL value
     * @property {number} DT_QINT8=11 DT_QINT8 value
     * @property {number} DT_QUINT8=12 DT_QUINT8 value
     * @property {number} DT_QINT32=13 DT_QINT32 value
     * @property {number} DT_BFLOAT16=14 DT_BFLOAT16 value
     * @property {number} DT_FLOAT_REF=101 DT_FLOAT_REF value
     * @property {number} DT_DOUBLE_REF=102 DT_DOUBLE_REF value
     * @property {number} DT_INT32_REF=103 DT_INT32_REF value
     * @property {number} DT_UINT8_REF=104 DT_UINT8_REF value
     * @property {number} DT_INT16_REF=105 DT_INT16_REF value
     * @property {number} DT_INT8_REF=106 DT_INT8_REF value
     * @property {number} DT_STRING_REF=107 DT_STRING_REF value
     * @property {number} DT_COMPLEX64_REF=108 DT_COMPLEX64_REF value
     * @property {number} DT_INT64_REF=109 DT_INT64_REF value
     * @property {number} DT_BOOL_REF=110 DT_BOOL_REF value
     * @property {number} DT_QINT8_REF=111 DT_QINT8_REF value
     * @property {number} DT_QUINT8_REF=112 DT_QUINT8_REF value
     * @property {number} DT_QINT32_REF=113 DT_QINT32_REF value
     * @property {number} DT_BFLOAT16_REF=114 DT_BFLOAT16_REF value
     */
    tensorflow.DataType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DT_INVALID"] = 0;
        values[valuesById[1] = "DT_FLOAT"] = 1;
        values[valuesById[2] = "DT_DOUBLE"] = 2;
        values[valuesById[3] = "DT_INT32"] = 3;
        values[valuesById[4] = "DT_UINT8"] = 4;
        values[valuesById[5] = "DT_INT16"] = 5;
        values[valuesById[6] = "DT_INT8"] = 6;
        values[valuesById[7] = "DT_STRING"] = 7;
        values[valuesById[8] = "DT_COMPLEX64"] = 8;
        values[valuesById[9] = "DT_INT64"] = 9;
        values[valuesById[10] = "DT_BOOL"] = 10;
        values[valuesById[11] = "DT_QINT8"] = 11;
        values[valuesById[12] = "DT_QUINT8"] = 12;
        values[valuesById[13] = "DT_QINT32"] = 13;
        values[valuesById[14] = "DT_BFLOAT16"] = 14;
        values[valuesById[101] = "DT_FLOAT_REF"] = 101;
        values[valuesById[102] = "DT_DOUBLE_REF"] = 102;
        values[valuesById[103] = "DT_INT32_REF"] = 103;
        values[valuesById[104] = "DT_UINT8_REF"] = 104;
        values[valuesById[105] = "DT_INT16_REF"] = 105;
        values[valuesById[106] = "DT_INT8_REF"] = 106;
        values[valuesById[107] = "DT_STRING_REF"] = 107;
        values[valuesById[108] = "DT_COMPLEX64_REF"] = 108;
        values[valuesById[109] = "DT_INT64_REF"] = 109;
        values[valuesById[110] = "DT_BOOL_REF"] = 110;
        values[valuesById[111] = "DT_QINT8_REF"] = 111;
        values[valuesById[112] = "DT_QUINT8_REF"] = 112;
        values[valuesById[113] = "DT_QINT32_REF"] = 113;
        values[valuesById[114] = "DT_BFLOAT16_REF"] = 114;
        return values;
    })();

    tensorflow.TensorShape = (function() {

        /**
         * Properties of a TensorShape.
         * @memberof tensorflow
         * @interface ITensorShape
         * @property {Array.<tensorflow.TensorShape.IDim>|null} [dim] TensorShape dim
         * @property {boolean|null} [unknownRank] TensorShape unknownRank
         */

        /**
         * Constructs a new TensorShape.
         * @memberof tensorflow
         * @classdesc Represents a TensorShape.
         * @implements ITensorShape
         * @constructor
         * @param {tensorflow.ITensorShape=} [properties] Properties to set
         */
        function TensorShape(properties) {
            this.dim = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TensorShape dim.
         * @member {Array.<tensorflow.TensorShape.IDim>} dim
         * @memberof tensorflow.TensorShape
         * @instance
         */
        TensorShape.prototype.dim = $util.emptyArray;

        /**
         * TensorShape unknownRank.
         * @member {boolean} unknownRank
         * @memberof tensorflow.TensorShape
         * @instance
         */
        TensorShape.prototype.unknownRank = false;

        /**
         * Creates a new TensorShape instance using the specified properties.
         * @function create
         * @memberof tensorflow.TensorShape
         * @static
         * @param {tensorflow.ITensorShape=} [properties] Properties to set
         * @returns {tensorflow.TensorShape} TensorShape instance
         */
        TensorShape.create = function create(properties) {
            return new TensorShape(properties);
        };

        /**
         * Encodes the specified TensorShape message. Does not implicitly {@link tensorflow.TensorShape.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.TensorShape
         * @static
         * @param {tensorflow.ITensorShape} message TensorShape message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorShape.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dim != null && message.dim.length)
                for (var i = 0; i < message.dim.length; ++i)
                    $root.tensorflow.TensorShape.Dim.encode(message.dim[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.unknownRank != null && message.hasOwnProperty("unknownRank"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.unknownRank);
            return writer;
        };

        /**
         * Encodes the specified TensorShape message, length delimited. Does not implicitly {@link tensorflow.TensorShape.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.TensorShape
         * @static
         * @param {tensorflow.ITensorShape} message TensorShape message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorShape.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TensorShape message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.TensorShape
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.TensorShape} TensorShape
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorShape.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.TensorShape();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    if (!(message.dim && message.dim.length))
                        message.dim = [];
                    message.dim.push($root.tensorflow.TensorShape.Dim.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.unknownRank = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TensorShape message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.TensorShape
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.TensorShape} TensorShape
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorShape.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TensorShape message.
         * @function verify
         * @memberof tensorflow.TensorShape
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TensorShape.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dim != null && message.hasOwnProperty("dim")) {
                if (!Array.isArray(message.dim))
                    return "dim: array expected";
                for (var i = 0; i < message.dim.length; ++i) {
                    var error = $root.tensorflow.TensorShape.Dim.verify(message.dim[i]);
                    if (error)
                        return "dim." + error;
                }
            }
            if (message.unknownRank != null && message.hasOwnProperty("unknownRank"))
                if (typeof message.unknownRank !== "boolean")
                    return "unknownRank: boolean expected";
            return null;
        };

        /**
         * Creates a TensorShape message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.TensorShape
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.TensorShape} TensorShape
         */
        TensorShape.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.TensorShape)
                return object;
            var message = new $root.tensorflow.TensorShape();
            if (object.dim) {
                if (!Array.isArray(object.dim))
                    throw TypeError(".tensorflow.TensorShape.dim: array expected");
                message.dim = [];
                for (var i = 0; i < object.dim.length; ++i) {
                    if (typeof object.dim[i] !== "object")
                        throw TypeError(".tensorflow.TensorShape.dim: object expected");
                    message.dim[i] = $root.tensorflow.TensorShape.Dim.fromObject(object.dim[i]);
                }
            }
            if (object.unknownRank != null)
                message.unknownRank = Boolean(object.unknownRank);
            return message;
        };

        /**
         * Creates a plain object from a TensorShape message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.TensorShape
         * @static
         * @param {tensorflow.TensorShape} message TensorShape
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TensorShape.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dim = [];
            if (options.defaults)
                object.unknownRank = false;
            if (message.dim && message.dim.length) {
                object.dim = [];
                for (var j = 0; j < message.dim.length; ++j)
                    object.dim[j] = $root.tensorflow.TensorShape.Dim.toObject(message.dim[j], options);
            }
            if (message.unknownRank != null && message.hasOwnProperty("unknownRank"))
                object.unknownRank = message.unknownRank;
            return object;
        };

        /**
         * Converts this TensorShape to JSON.
         * @function toJSON
         * @memberof tensorflow.TensorShape
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TensorShape.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        TensorShape.Dim = (function() {

            /**
             * Properties of a Dim.
             * @memberof tensorflow.TensorShape
             * @interface IDim
             * @property {number|Long|null} [size] Dim size
             * @property {string|null} [name] Dim name
             */

            /**
             * Constructs a new Dim.
             * @memberof tensorflow.TensorShape
             * @classdesc Represents a Dim.
             * @implements IDim
             * @constructor
             * @param {tensorflow.TensorShape.IDim=} [properties] Properties to set
             */
            function Dim(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Dim size.
             * @member {number|Long} size
             * @memberof tensorflow.TensorShape.Dim
             * @instance
             */
            Dim.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Dim name.
             * @member {string} name
             * @memberof tensorflow.TensorShape.Dim
             * @instance
             */
            Dim.prototype.name = "";

            /**
             * Creates a new Dim instance using the specified properties.
             * @function create
             * @memberof tensorflow.TensorShape.Dim
             * @static
             * @param {tensorflow.TensorShape.IDim=} [properties] Properties to set
             * @returns {tensorflow.TensorShape.Dim} Dim instance
             */
            Dim.create = function create(properties) {
                return new Dim(properties);
            };

            /**
             * Encodes the specified Dim message. Does not implicitly {@link tensorflow.TensorShape.Dim.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.TensorShape.Dim
             * @static
             * @param {tensorflow.TensorShape.IDim} message Dim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dim.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.size != null && message.hasOwnProperty("size"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.size);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified Dim message, length delimited. Does not implicitly {@link tensorflow.TensorShape.Dim.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.TensorShape.Dim
             * @static
             * @param {tensorflow.TensorShape.IDim} message Dim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dim.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Dim message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.TensorShape.Dim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.TensorShape.Dim} Dim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dim.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.TensorShape.Dim();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.size = reader.int64();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Dim message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.TensorShape.Dim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.TensorShape.Dim} Dim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dim.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Dim message.
             * @function verify
             * @memberof tensorflow.TensorShape.Dim
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Dim.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.size != null && message.hasOwnProperty("size"))
                    if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                        return "size: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a Dim message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.TensorShape.Dim
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.TensorShape.Dim} Dim
             */
            Dim.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.TensorShape.Dim)
                    return object;
                var message = new $root.tensorflow.TensorShape.Dim();
                if (object.size != null)
                    if ($util.Long)
                        (message.size = $util.Long.fromValue(object.size)).unsigned = false;
                    else if (typeof object.size === "string")
                        message.size = parseInt(object.size, 10);
                    else if (typeof object.size === "number")
                        message.size = object.size;
                    else if (typeof object.size === "object")
                        message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a Dim message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.TensorShape.Dim
             * @static
             * @param {tensorflow.TensorShape.Dim} message Dim
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Dim.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.size = options.longs === String ? "0" : 0;
                    object.name = "";
                }
                if (message.size != null && message.hasOwnProperty("size"))
                    if (typeof message.size === "number")
                        object.size = options.longs === String ? String(message.size) : message.size;
                    else
                        object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this Dim to JSON.
             * @function toJSON
             * @memberof tensorflow.TensorShape.Dim
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Dim.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Dim;
        })();

        return TensorShape;
    })();

    tensorflow.Tensor = (function() {

        /**
         * Properties of a Tensor.
         * @memberof tensorflow
         * @interface ITensor
         * @property {tensorflow.DataType|null} [dtype] Tensor dtype
         * @property {tensorflow.ITensorShape|null} [tensorShape] Tensor tensorShape
         * @property {number|null} [versionNumber] Tensor versionNumber
         * @property {Uint8Array|null} [tensorContent] Tensor tensorContent
         * @property {Array.<number>|null} [floatVal] Tensor floatVal
         * @property {Array.<number>|null} [doubleVal] Tensor doubleVal
         * @property {Array.<number>|null} [intVal] Tensor intVal
         * @property {Array.<Uint8Array>|null} [stringVal] Tensor stringVal
         * @property {Array.<number>|null} [scomplexVal] Tensor scomplexVal
         * @property {Array.<number|Long>|null} [int64Val] Tensor int64Val
         * @property {Array.<boolean>|null} [boolVal] Tensor boolVal
         * @property {Array.<number>|null} [uint32Val] Tensor uint32Val
         * @property {Array.<number|Long>|null} [uint64Val] Tensor uint64Val
         */

        /**
         * Constructs a new Tensor.
         * @memberof tensorflow
         * @classdesc Represents a Tensor.
         * @implements ITensor
         * @constructor
         * @param {tensorflow.ITensor=} [properties] Properties to set
         */
        function Tensor(properties) {
            this.floatVal = [];
            this.doubleVal = [];
            this.intVal = [];
            this.stringVal = [];
            this.scomplexVal = [];
            this.int64Val = [];
            this.boolVal = [];
            this.uint32Val = [];
            this.uint64Val = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tensor dtype.
         * @member {tensorflow.DataType} dtype
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.dtype = 0;

        /**
         * Tensor tensorShape.
         * @member {tensorflow.ITensorShape|null|undefined} tensorShape
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.tensorShape = null;

        /**
         * Tensor versionNumber.
         * @member {number} versionNumber
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.versionNumber = 0;

        /**
         * Tensor tensorContent.
         * @member {Uint8Array} tensorContent
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.tensorContent = $util.newBuffer([]);

        /**
         * Tensor floatVal.
         * @member {Array.<number>} floatVal
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.floatVal = $util.emptyArray;

        /**
         * Tensor doubleVal.
         * @member {Array.<number>} doubleVal
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.doubleVal = $util.emptyArray;

        /**
         * Tensor intVal.
         * @member {Array.<number>} intVal
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.intVal = $util.emptyArray;

        /**
         * Tensor stringVal.
         * @member {Array.<Uint8Array>} stringVal
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.stringVal = $util.emptyArray;

        /**
         * Tensor scomplexVal.
         * @member {Array.<number>} scomplexVal
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.scomplexVal = $util.emptyArray;

        /**
         * Tensor int64Val.
         * @member {Array.<number|Long>} int64Val
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.int64Val = $util.emptyArray;

        /**
         * Tensor boolVal.
         * @member {Array.<boolean>} boolVal
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.boolVal = $util.emptyArray;

        /**
         * Tensor uint32Val.
         * @member {Array.<number>} uint32Val
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.uint32Val = $util.emptyArray;

        /**
         * Tensor uint64Val.
         * @member {Array.<number|Long>} uint64Val
         * @memberof tensorflow.Tensor
         * @instance
         */
        Tensor.prototype.uint64Val = $util.emptyArray;

        /**
         * Creates a new Tensor instance using the specified properties.
         * @function create
         * @memberof tensorflow.Tensor
         * @static
         * @param {tensorflow.ITensor=} [properties] Properties to set
         * @returns {tensorflow.Tensor} Tensor instance
         */
        Tensor.create = function create(properties) {
            return new Tensor(properties);
        };

        /**
         * Encodes the specified Tensor message. Does not implicitly {@link tensorflow.Tensor.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.Tensor
         * @static
         * @param {tensorflow.ITensor} message Tensor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tensor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dtype != null && message.hasOwnProperty("dtype"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dtype);
            if (message.tensorShape != null && message.hasOwnProperty("tensorShape"))
                $root.tensorflow.TensorShape.encode(message.tensorShape, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.versionNumber != null && message.hasOwnProperty("versionNumber"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.versionNumber);
            if (message.tensorContent != null && message.hasOwnProperty("tensorContent"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tensorContent);
            if (message.floatVal != null && message.floatVal.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.floatVal.length; ++i)
                    writer.float(message.floatVal[i]);
                writer.ldelim();
            }
            if (message.doubleVal != null && message.doubleVal.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (var i = 0; i < message.doubleVal.length; ++i)
                    writer.double(message.doubleVal[i]);
                writer.ldelim();
            }
            if (message.intVal != null && message.intVal.length) {
                writer.uint32(/* id 7, wireType 2 =*/58).fork();
                for (var i = 0; i < message.intVal.length; ++i)
                    writer.int32(message.intVal[i]);
                writer.ldelim();
            }
            if (message.stringVal != null && message.stringVal.length)
                for (var i = 0; i < message.stringVal.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.stringVal[i]);
            if (message.scomplexVal != null && message.scomplexVal.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (var i = 0; i < message.scomplexVal.length; ++i)
                    writer.float(message.scomplexVal[i]);
                writer.ldelim();
            }
            if (message.int64Val != null && message.int64Val.length) {
                writer.uint32(/* id 10, wireType 2 =*/82).fork();
                for (var i = 0; i < message.int64Val.length; ++i)
                    writer.int64(message.int64Val[i]);
                writer.ldelim();
            }
            if (message.boolVal != null && message.boolVal.length) {
                writer.uint32(/* id 11, wireType 2 =*/90).fork();
                for (var i = 0; i < message.boolVal.length; ++i)
                    writer.bool(message.boolVal[i]);
                writer.ldelim();
            }
            if (message.uint32Val != null && message.uint32Val.length) {
                writer.uint32(/* id 16, wireType 2 =*/130).fork();
                for (var i = 0; i < message.uint32Val.length; ++i)
                    writer.uint32(message.uint32Val[i]);
                writer.ldelim();
            }
            if (message.uint64Val != null && message.uint64Val.length) {
                writer.uint32(/* id 17, wireType 2 =*/138).fork();
                for (var i = 0; i < message.uint64Val.length; ++i)
                    writer.uint64(message.uint64Val[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified Tensor message, length delimited. Does not implicitly {@link tensorflow.Tensor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.Tensor
         * @static
         * @param {tensorflow.ITensor} message Tensor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tensor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tensor message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.Tensor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.Tensor} Tensor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tensor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.Tensor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dtype = reader.int32();
                    break;
                case 2:
                    message.tensorShape = $root.tensorflow.TensorShape.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.versionNumber = reader.int32();
                    break;
                case 4:
                    message.tensorContent = reader.bytes();
                    break;
                case 5:
                    if (!(message.floatVal && message.floatVal.length))
                        message.floatVal = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.floatVal.push(reader.float());
                    } else
                        message.floatVal.push(reader.float());
                    break;
                case 6:
                    if (!(message.doubleVal && message.doubleVal.length))
                        message.doubleVal = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.doubleVal.push(reader.double());
                    } else
                        message.doubleVal.push(reader.double());
                    break;
                case 7:
                    if (!(message.intVal && message.intVal.length))
                        message.intVal = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.intVal.push(reader.int32());
                    } else
                        message.intVal.push(reader.int32());
                    break;
                case 8:
                    if (!(message.stringVal && message.stringVal.length))
                        message.stringVal = [];
                    message.stringVal.push(reader.bytes());
                    break;
                case 9:
                    if (!(message.scomplexVal && message.scomplexVal.length))
                        message.scomplexVal = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.scomplexVal.push(reader.float());
                    } else
                        message.scomplexVal.push(reader.float());
                    break;
                case 10:
                    if (!(message.int64Val && message.int64Val.length))
                        message.int64Val = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.int64Val.push(reader.int64());
                    } else
                        message.int64Val.push(reader.int64());
                    break;
                case 11:
                    if (!(message.boolVal && message.boolVal.length))
                        message.boolVal = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.boolVal.push(reader.bool());
                    } else
                        message.boolVal.push(reader.bool());
                    break;
                case 16:
                    if (!(message.uint32Val && message.uint32Val.length))
                        message.uint32Val = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.uint32Val.push(reader.uint32());
                    } else
                        message.uint32Val.push(reader.uint32());
                    break;
                case 17:
                    if (!(message.uint64Val && message.uint64Val.length))
                        message.uint64Val = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.uint64Val.push(reader.uint64());
                    } else
                        message.uint64Val.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Tensor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.Tensor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.Tensor} Tensor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tensor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tensor message.
         * @function verify
         * @memberof tensorflow.Tensor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tensor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dtype != null && message.hasOwnProperty("dtype"))
                switch (message.dtype) {
                default:
                    return "dtype: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                    break;
                }
            if (message.tensorShape != null && message.hasOwnProperty("tensorShape")) {
                var error = $root.tensorflow.TensorShape.verify(message.tensorShape);
                if (error)
                    return "tensorShape." + error;
            }
            if (message.versionNumber != null && message.hasOwnProperty("versionNumber"))
                if (!$util.isInteger(message.versionNumber))
                    return "versionNumber: integer expected";
            if (message.tensorContent != null && message.hasOwnProperty("tensorContent"))
                if (!(message.tensorContent && typeof message.tensorContent.length === "number" || $util.isString(message.tensorContent)))
                    return "tensorContent: buffer expected";
            if (message.floatVal != null && message.hasOwnProperty("floatVal")) {
                if (!Array.isArray(message.floatVal))
                    return "floatVal: array expected";
                for (var i = 0; i < message.floatVal.length; ++i)
                    if (typeof message.floatVal[i] !== "number")
                        return "floatVal: number[] expected";
            }
            if (message.doubleVal != null && message.hasOwnProperty("doubleVal")) {
                if (!Array.isArray(message.doubleVal))
                    return "doubleVal: array expected";
                for (var i = 0; i < message.doubleVal.length; ++i)
                    if (typeof message.doubleVal[i] !== "number")
                        return "doubleVal: number[] expected";
            }
            if (message.intVal != null && message.hasOwnProperty("intVal")) {
                if (!Array.isArray(message.intVal))
                    return "intVal: array expected";
                for (var i = 0; i < message.intVal.length; ++i)
                    if (!$util.isInteger(message.intVal[i]))
                        return "intVal: integer[] expected";
            }
            if (message.stringVal != null && message.hasOwnProperty("stringVal")) {
                if (!Array.isArray(message.stringVal))
                    return "stringVal: array expected";
                for (var i = 0; i < message.stringVal.length; ++i)
                    if (!(message.stringVal[i] && typeof message.stringVal[i].length === "number" || $util.isString(message.stringVal[i])))
                        return "stringVal: buffer[] expected";
            }
            if (message.scomplexVal != null && message.hasOwnProperty("scomplexVal")) {
                if (!Array.isArray(message.scomplexVal))
                    return "scomplexVal: array expected";
                for (var i = 0; i < message.scomplexVal.length; ++i)
                    if (typeof message.scomplexVal[i] !== "number")
                        return "scomplexVal: number[] expected";
            }
            if (message.int64Val != null && message.hasOwnProperty("int64Val")) {
                if (!Array.isArray(message.int64Val))
                    return "int64Val: array expected";
                for (var i = 0; i < message.int64Val.length; ++i)
                    if (!$util.isInteger(message.int64Val[i]) && !(message.int64Val[i] && $util.isInteger(message.int64Val[i].low) && $util.isInteger(message.int64Val[i].high)))
                        return "int64Val: integer|Long[] expected";
            }
            if (message.boolVal != null && message.hasOwnProperty("boolVal")) {
                if (!Array.isArray(message.boolVal))
                    return "boolVal: array expected";
                for (var i = 0; i < message.boolVal.length; ++i)
                    if (typeof message.boolVal[i] !== "boolean")
                        return "boolVal: boolean[] expected";
            }
            if (message.uint32Val != null && message.hasOwnProperty("uint32Val")) {
                if (!Array.isArray(message.uint32Val))
                    return "uint32Val: array expected";
                for (var i = 0; i < message.uint32Val.length; ++i)
                    if (!$util.isInteger(message.uint32Val[i]))
                        return "uint32Val: integer[] expected";
            }
            if (message.uint64Val != null && message.hasOwnProperty("uint64Val")) {
                if (!Array.isArray(message.uint64Val))
                    return "uint64Val: array expected";
                for (var i = 0; i < message.uint64Val.length; ++i)
                    if (!$util.isInteger(message.uint64Val[i]) && !(message.uint64Val[i] && $util.isInteger(message.uint64Val[i].low) && $util.isInteger(message.uint64Val[i].high)))
                        return "uint64Val: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a Tensor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.Tensor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.Tensor} Tensor
         */
        Tensor.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.Tensor)
                return object;
            var message = new $root.tensorflow.Tensor();
            switch (object.dtype) {
            case "DT_INVALID":
            case 0:
                message.dtype = 0;
                break;
            case "DT_FLOAT":
            case 1:
                message.dtype = 1;
                break;
            case "DT_DOUBLE":
            case 2:
                message.dtype = 2;
                break;
            case "DT_INT32":
            case 3:
                message.dtype = 3;
                break;
            case "DT_UINT8":
            case 4:
                message.dtype = 4;
                break;
            case "DT_INT16":
            case 5:
                message.dtype = 5;
                break;
            case "DT_INT8":
            case 6:
                message.dtype = 6;
                break;
            case "DT_STRING":
            case 7:
                message.dtype = 7;
                break;
            case "DT_COMPLEX64":
            case 8:
                message.dtype = 8;
                break;
            case "DT_INT64":
            case 9:
                message.dtype = 9;
                break;
            case "DT_BOOL":
            case 10:
                message.dtype = 10;
                break;
            case "DT_QINT8":
            case 11:
                message.dtype = 11;
                break;
            case "DT_QUINT8":
            case 12:
                message.dtype = 12;
                break;
            case "DT_QINT32":
            case 13:
                message.dtype = 13;
                break;
            case "DT_BFLOAT16":
            case 14:
                message.dtype = 14;
                break;
            case "DT_FLOAT_REF":
            case 101:
                message.dtype = 101;
                break;
            case "DT_DOUBLE_REF":
            case 102:
                message.dtype = 102;
                break;
            case "DT_INT32_REF":
            case 103:
                message.dtype = 103;
                break;
            case "DT_UINT8_REF":
            case 104:
                message.dtype = 104;
                break;
            case "DT_INT16_REF":
            case 105:
                message.dtype = 105;
                break;
            case "DT_INT8_REF":
            case 106:
                message.dtype = 106;
                break;
            case "DT_STRING_REF":
            case 107:
                message.dtype = 107;
                break;
            case "DT_COMPLEX64_REF":
            case 108:
                message.dtype = 108;
                break;
            case "DT_INT64_REF":
            case 109:
                message.dtype = 109;
                break;
            case "DT_BOOL_REF":
            case 110:
                message.dtype = 110;
                break;
            case "DT_QINT8_REF":
            case 111:
                message.dtype = 111;
                break;
            case "DT_QUINT8_REF":
            case 112:
                message.dtype = 112;
                break;
            case "DT_QINT32_REF":
            case 113:
                message.dtype = 113;
                break;
            case "DT_BFLOAT16_REF":
            case 114:
                message.dtype = 114;
                break;
            }
            if (object.tensorShape != null) {
                if (typeof object.tensorShape !== "object")
                    throw TypeError(".tensorflow.Tensor.tensorShape: object expected");
                message.tensorShape = $root.tensorflow.TensorShape.fromObject(object.tensorShape);
            }
            if (object.versionNumber != null)
                message.versionNumber = object.versionNumber | 0;
            if (object.tensorContent != null)
                if (typeof object.tensorContent === "string")
                    $util.base64.decode(object.tensorContent, message.tensorContent = $util.newBuffer($util.base64.length(object.tensorContent)), 0);
                else if (object.tensorContent.length)
                    message.tensorContent = object.tensorContent;
            if (object.floatVal) {
                if (!Array.isArray(object.floatVal))
                    throw TypeError(".tensorflow.Tensor.floatVal: array expected");
                message.floatVal = [];
                for (var i = 0; i < object.floatVal.length; ++i)
                    message.floatVal[i] = Number(object.floatVal[i]);
            }
            if (object.doubleVal) {
                if (!Array.isArray(object.doubleVal))
                    throw TypeError(".tensorflow.Tensor.doubleVal: array expected");
                message.doubleVal = [];
                for (var i = 0; i < object.doubleVal.length; ++i)
                    message.doubleVal[i] = Number(object.doubleVal[i]);
            }
            if (object.intVal) {
                if (!Array.isArray(object.intVal))
                    throw TypeError(".tensorflow.Tensor.intVal: array expected");
                message.intVal = [];
                for (var i = 0; i < object.intVal.length; ++i)
                    message.intVal[i] = object.intVal[i] | 0;
            }
            if (object.stringVal) {
                if (!Array.isArray(object.stringVal))
                    throw TypeError(".tensorflow.Tensor.stringVal: array expected");
                message.stringVal = [];
                for (var i = 0; i < object.stringVal.length; ++i)
                    if (typeof object.stringVal[i] === "string")
                        $util.base64.decode(object.stringVal[i], message.stringVal[i] = $util.newBuffer($util.base64.length(object.stringVal[i])), 0);
                    else if (object.stringVal[i].length)
                        message.stringVal[i] = object.stringVal[i];
            }
            if (object.scomplexVal) {
                if (!Array.isArray(object.scomplexVal))
                    throw TypeError(".tensorflow.Tensor.scomplexVal: array expected");
                message.scomplexVal = [];
                for (var i = 0; i < object.scomplexVal.length; ++i)
                    message.scomplexVal[i] = Number(object.scomplexVal[i]);
            }
            if (object.int64Val) {
                if (!Array.isArray(object.int64Val))
                    throw TypeError(".tensorflow.Tensor.int64Val: array expected");
                message.int64Val = [];
                for (var i = 0; i < object.int64Val.length; ++i)
                    if ($util.Long)
                        (message.int64Val[i] = $util.Long.fromValue(object.int64Val[i])).unsigned = false;
                    else if (typeof object.int64Val[i] === "string")
                        message.int64Val[i] = parseInt(object.int64Val[i], 10);
                    else if (typeof object.int64Val[i] === "number")
                        message.int64Val[i] = object.int64Val[i];
                    else if (typeof object.int64Val[i] === "object")
                        message.int64Val[i] = new $util.LongBits(object.int64Val[i].low >>> 0, object.int64Val[i].high >>> 0).toNumber();
            }
            if (object.boolVal) {
                if (!Array.isArray(object.boolVal))
                    throw TypeError(".tensorflow.Tensor.boolVal: array expected");
                message.boolVal = [];
                for (var i = 0; i < object.boolVal.length; ++i)
                    message.boolVal[i] = Boolean(object.boolVal[i]);
            }
            if (object.uint32Val) {
                if (!Array.isArray(object.uint32Val))
                    throw TypeError(".tensorflow.Tensor.uint32Val: array expected");
                message.uint32Val = [];
                for (var i = 0; i < object.uint32Val.length; ++i)
                    message.uint32Val[i] = object.uint32Val[i] >>> 0;
            }
            if (object.uint64Val) {
                if (!Array.isArray(object.uint64Val))
                    throw TypeError(".tensorflow.Tensor.uint64Val: array expected");
                message.uint64Val = [];
                for (var i = 0; i < object.uint64Val.length; ++i)
                    if ($util.Long)
                        (message.uint64Val[i] = $util.Long.fromValue(object.uint64Val[i])).unsigned = true;
                    else if (typeof object.uint64Val[i] === "string")
                        message.uint64Val[i] = parseInt(object.uint64Val[i], 10);
                    else if (typeof object.uint64Val[i] === "number")
                        message.uint64Val[i] = object.uint64Val[i];
                    else if (typeof object.uint64Val[i] === "object")
                        message.uint64Val[i] = new $util.LongBits(object.uint64Val[i].low >>> 0, object.uint64Val[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a plain object from a Tensor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.Tensor
         * @static
         * @param {tensorflow.Tensor} message Tensor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tensor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.floatVal = [];
                object.doubleVal = [];
                object.intVal = [];
                object.stringVal = [];
                object.scomplexVal = [];
                object.int64Val = [];
                object.boolVal = [];
                object.uint32Val = [];
                object.uint64Val = [];
            }
            if (options.defaults) {
                object.dtype = options.enums === String ? "DT_INVALID" : 0;
                object.tensorShape = null;
                object.versionNumber = 0;
                object.tensorContent = options.bytes === String ? "" : [];
            }
            if (message.dtype != null && message.hasOwnProperty("dtype"))
                object.dtype = options.enums === String ? $root.tensorflow.DataType[message.dtype] : message.dtype;
            if (message.tensorShape != null && message.hasOwnProperty("tensorShape"))
                object.tensorShape = $root.tensorflow.TensorShape.toObject(message.tensorShape, options);
            if (message.versionNumber != null && message.hasOwnProperty("versionNumber"))
                object.versionNumber = message.versionNumber;
            if (message.tensorContent != null && message.hasOwnProperty("tensorContent"))
                object.tensorContent = options.bytes === String ? $util.base64.encode(message.tensorContent, 0, message.tensorContent.length) : options.bytes === Array ? Array.prototype.slice.call(message.tensorContent) : message.tensorContent;
            if (message.floatVal && message.floatVal.length) {
                object.floatVal = [];
                for (var j = 0; j < message.floatVal.length; ++j)
                    object.floatVal[j] = options.json && !isFinite(message.floatVal[j]) ? String(message.floatVal[j]) : message.floatVal[j];
            }
            if (message.doubleVal && message.doubleVal.length) {
                object.doubleVal = [];
                for (var j = 0; j < message.doubleVal.length; ++j)
                    object.doubleVal[j] = options.json && !isFinite(message.doubleVal[j]) ? String(message.doubleVal[j]) : message.doubleVal[j];
            }
            if (message.intVal && message.intVal.length) {
                object.intVal = [];
                for (var j = 0; j < message.intVal.length; ++j)
                    object.intVal[j] = message.intVal[j];
            }
            if (message.stringVal && message.stringVal.length) {
                object.stringVal = [];
                for (var j = 0; j < message.stringVal.length; ++j)
                    object.stringVal[j] = options.bytes === String ? $util.base64.encode(message.stringVal[j], 0, message.stringVal[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.stringVal[j]) : message.stringVal[j];
            }
            if (message.scomplexVal && message.scomplexVal.length) {
                object.scomplexVal = [];
                for (var j = 0; j < message.scomplexVal.length; ++j)
                    object.scomplexVal[j] = options.json && !isFinite(message.scomplexVal[j]) ? String(message.scomplexVal[j]) : message.scomplexVal[j];
            }
            if (message.int64Val && message.int64Val.length) {
                object.int64Val = [];
                for (var j = 0; j < message.int64Val.length; ++j)
                    if (typeof message.int64Val[j] === "number")
                        object.int64Val[j] = options.longs === String ? String(message.int64Val[j]) : message.int64Val[j];
                    else
                        object.int64Val[j] = options.longs === String ? $util.Long.prototype.toString.call(message.int64Val[j]) : options.longs === Number ? new $util.LongBits(message.int64Val[j].low >>> 0, message.int64Val[j].high >>> 0).toNumber() : message.int64Val[j];
            }
            if (message.boolVal && message.boolVal.length) {
                object.boolVal = [];
                for (var j = 0; j < message.boolVal.length; ++j)
                    object.boolVal[j] = message.boolVal[j];
            }
            if (message.uint32Val && message.uint32Val.length) {
                object.uint32Val = [];
                for (var j = 0; j < message.uint32Val.length; ++j)
                    object.uint32Val[j] = message.uint32Val[j];
            }
            if (message.uint64Val && message.uint64Val.length) {
                object.uint64Val = [];
                for (var j = 0; j < message.uint64Val.length; ++j)
                    if (typeof message.uint64Val[j] === "number")
                        object.uint64Val[j] = options.longs === String ? String(message.uint64Val[j]) : message.uint64Val[j];
                    else
                        object.uint64Val[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Val[j]) : options.longs === Number ? new $util.LongBits(message.uint64Val[j].low >>> 0, message.uint64Val[j].high >>> 0).toNumber(true) : message.uint64Val[j];
            }
            return object;
        };

        /**
         * Converts this Tensor to JSON.
         * @function toJSON
         * @memberof tensorflow.Tensor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tensor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Tensor;
    })();

    tensorflow.AttrValue = (function() {

        /**
         * Properties of an AttrValue.
         * @memberof tensorflow
         * @interface IAttrValue
         * @property {tensorflow.AttrValue.IListValue|null} [list] AttrValue list
         * @property {Uint8Array|null} [s] AttrValue s
         * @property {number|Long|null} [i] AttrValue i
         * @property {number|null} [f] AttrValue f
         * @property {boolean|null} [b] AttrValue b
         * @property {tensorflow.DataType|null} [type] AttrValue type
         * @property {tensorflow.ITensorShape|null} [shape] AttrValue shape
         * @property {tensorflow.ITensor|null} [tensor] AttrValue tensor
         * @property {string|null} [placeholder] AttrValue placeholder
         * @property {tensorflow.INameAttrList|null} [func] AttrValue func
         */

        /**
         * Constructs a new AttrValue.
         * @memberof tensorflow
         * @classdesc Represents an AttrValue.
         * @implements IAttrValue
         * @constructor
         * @param {tensorflow.IAttrValue=} [properties] Properties to set
         */
        function AttrValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AttrValue list.
         * @member {tensorflow.AttrValue.IListValue|null|undefined} list
         * @memberof tensorflow.AttrValue
         * @instance
         */
        AttrValue.prototype.list = null;

        /**
         * AttrValue s.
         * @member {Uint8Array} s
         * @memberof tensorflow.AttrValue
         * @instance
         */
        AttrValue.prototype.s = $util.newBuffer([]);

        /**
         * AttrValue i.
         * @member {number|Long} i
         * @memberof tensorflow.AttrValue
         * @instance
         */
        AttrValue.prototype.i = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AttrValue f.
         * @member {number} f
         * @memberof tensorflow.AttrValue
         * @instance
         */
        AttrValue.prototype.f = 0;

        /**
         * AttrValue b.
         * @member {boolean} b
         * @memberof tensorflow.AttrValue
         * @instance
         */
        AttrValue.prototype.b = false;

        /**
         * AttrValue type.
         * @member {tensorflow.DataType} type
         * @memberof tensorflow.AttrValue
         * @instance
         */
        AttrValue.prototype.type = 0;

        /**
         * AttrValue shape.
         * @member {tensorflow.ITensorShape|null|undefined} shape
         * @memberof tensorflow.AttrValue
         * @instance
         */
        AttrValue.prototype.shape = null;

        /**
         * AttrValue tensor.
         * @member {tensorflow.ITensor|null|undefined} tensor
         * @memberof tensorflow.AttrValue
         * @instance
         */
        AttrValue.prototype.tensor = null;

        /**
         * AttrValue placeholder.
         * @member {string} placeholder
         * @memberof tensorflow.AttrValue
         * @instance
         */
        AttrValue.prototype.placeholder = "";

        /**
         * AttrValue func.
         * @member {tensorflow.INameAttrList|null|undefined} func
         * @memberof tensorflow.AttrValue
         * @instance
         */
        AttrValue.prototype.func = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * AttrValue value.
         * @member {"list"|"s"|"i"|"f"|"b"|"type"|"shape"|"tensor"|"placeholder"|"func"|undefined} value
         * @memberof tensorflow.AttrValue
         * @instance
         */
        Object.defineProperty(AttrValue.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["list", "s", "i", "f", "b", "type", "shape", "tensor", "placeholder", "func"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new AttrValue instance using the specified properties.
         * @function create
         * @memberof tensorflow.AttrValue
         * @static
         * @param {tensorflow.IAttrValue=} [properties] Properties to set
         * @returns {tensorflow.AttrValue} AttrValue instance
         */
        AttrValue.create = function create(properties) {
            return new AttrValue(properties);
        };

        /**
         * Encodes the specified AttrValue message. Does not implicitly {@link tensorflow.AttrValue.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.AttrValue
         * @static
         * @param {tensorflow.IAttrValue} message AttrValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttrValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.list != null && message.hasOwnProperty("list"))
                $root.tensorflow.AttrValue.ListValue.encode(message.list, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.s != null && message.hasOwnProperty("s"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.s);
            if (message.i != null && message.hasOwnProperty("i"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.i);
            if (message.f != null && message.hasOwnProperty("f"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.f);
            if (message.b != null && message.hasOwnProperty("b"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.b);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            if (message.shape != null && message.hasOwnProperty("shape"))
                $root.tensorflow.TensorShape.encode(message.shape, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.tensor != null && message.hasOwnProperty("tensor"))
                $root.tensorflow.Tensor.encode(message.tensor, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.placeholder != null && message.hasOwnProperty("placeholder"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.placeholder);
            if (message.func != null && message.hasOwnProperty("func"))
                $root.tensorflow.NameAttrList.encode(message.func, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AttrValue message, length delimited. Does not implicitly {@link tensorflow.AttrValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.AttrValue
         * @static
         * @param {tensorflow.IAttrValue} message AttrValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttrValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AttrValue message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.AttrValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.AttrValue} AttrValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttrValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.AttrValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.list = $root.tensorflow.AttrValue.ListValue.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.s = reader.bytes();
                    break;
                case 3:
                    message.i = reader.int64();
                    break;
                case 4:
                    message.f = reader.float();
                    break;
                case 5:
                    message.b = reader.bool();
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                case 7:
                    message.shape = $root.tensorflow.TensorShape.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.tensor = $root.tensorflow.Tensor.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.placeholder = reader.string();
                    break;
                case 10:
                    message.func = $root.tensorflow.NameAttrList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AttrValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.AttrValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.AttrValue} AttrValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttrValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AttrValue message.
         * @function verify
         * @memberof tensorflow.AttrValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AttrValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.list != null && message.hasOwnProperty("list")) {
                properties.value = 1;
                {
                    var error = $root.tensorflow.AttrValue.ListValue.verify(message.list);
                    if (error)
                        return "list." + error;
                }
            }
            if (message.s != null && message.hasOwnProperty("s")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
                    return "s: buffer expected";
            }
            if (message.i != null && message.hasOwnProperty("i")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.i) && !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high)))
                    return "i: integer|Long expected";
            }
            if (message.f != null && message.hasOwnProperty("f")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (typeof message.f !== "number")
                    return "f: number expected";
            }
            if (message.b != null && message.hasOwnProperty("b")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (typeof message.b !== "boolean")
                    return "b: boolean expected";
            }
            if (message.type != null && message.hasOwnProperty("type")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                    break;
                }
            }
            if (message.shape != null && message.hasOwnProperty("shape")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    var error = $root.tensorflow.TensorShape.verify(message.shape);
                    if (error)
                        return "shape." + error;
                }
            }
            if (message.tensor != null && message.hasOwnProperty("tensor")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    var error = $root.tensorflow.Tensor.verify(message.tensor);
                    if (error)
                        return "tensor." + error;
                }
            }
            if (message.placeholder != null && message.hasOwnProperty("placeholder")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.placeholder))
                    return "placeholder: string expected";
            }
            if (message.func != null && message.hasOwnProperty("func")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    var error = $root.tensorflow.NameAttrList.verify(message.func);
                    if (error)
                        return "func." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AttrValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.AttrValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.AttrValue} AttrValue
         */
        AttrValue.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.AttrValue)
                return object;
            var message = new $root.tensorflow.AttrValue();
            if (object.list != null) {
                if (typeof object.list !== "object")
                    throw TypeError(".tensorflow.AttrValue.list: object expected");
                message.list = $root.tensorflow.AttrValue.ListValue.fromObject(object.list);
            }
            if (object.s != null)
                if (typeof object.s === "string")
                    $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
                else if (object.s.length)
                    message.s = object.s;
            if (object.i != null)
                if ($util.Long)
                    (message.i = $util.Long.fromValue(object.i)).unsigned = false;
                else if (typeof object.i === "string")
                    message.i = parseInt(object.i, 10);
                else if (typeof object.i === "number")
                    message.i = object.i;
                else if (typeof object.i === "object")
                    message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();
            if (object.f != null)
                message.f = Number(object.f);
            if (object.b != null)
                message.b = Boolean(object.b);
            switch (object.type) {
            case "DT_INVALID":
            case 0:
                message.type = 0;
                break;
            case "DT_FLOAT":
            case 1:
                message.type = 1;
                break;
            case "DT_DOUBLE":
            case 2:
                message.type = 2;
                break;
            case "DT_INT32":
            case 3:
                message.type = 3;
                break;
            case "DT_UINT8":
            case 4:
                message.type = 4;
                break;
            case "DT_INT16":
            case 5:
                message.type = 5;
                break;
            case "DT_INT8":
            case 6:
                message.type = 6;
                break;
            case "DT_STRING":
            case 7:
                message.type = 7;
                break;
            case "DT_COMPLEX64":
            case 8:
                message.type = 8;
                break;
            case "DT_INT64":
            case 9:
                message.type = 9;
                break;
            case "DT_BOOL":
            case 10:
                message.type = 10;
                break;
            case "DT_QINT8":
            case 11:
                message.type = 11;
                break;
            case "DT_QUINT8":
            case 12:
                message.type = 12;
                break;
            case "DT_QINT32":
            case 13:
                message.type = 13;
                break;
            case "DT_BFLOAT16":
            case 14:
                message.type = 14;
                break;
            case "DT_FLOAT_REF":
            case 101:
                message.type = 101;
                break;
            case "DT_DOUBLE_REF":
            case 102:
                message.type = 102;
                break;
            case "DT_INT32_REF":
            case 103:
                message.type = 103;
                break;
            case "DT_UINT8_REF":
            case 104:
                message.type = 104;
                break;
            case "DT_INT16_REF":
            case 105:
                message.type = 105;
                break;
            case "DT_INT8_REF":
            case 106:
                message.type = 106;
                break;
            case "DT_STRING_REF":
            case 107:
                message.type = 107;
                break;
            case "DT_COMPLEX64_REF":
            case 108:
                message.type = 108;
                break;
            case "DT_INT64_REF":
            case 109:
                message.type = 109;
                break;
            case "DT_BOOL_REF":
            case 110:
                message.type = 110;
                break;
            case "DT_QINT8_REF":
            case 111:
                message.type = 111;
                break;
            case "DT_QUINT8_REF":
            case 112:
                message.type = 112;
                break;
            case "DT_QINT32_REF":
            case 113:
                message.type = 113;
                break;
            case "DT_BFLOAT16_REF":
            case 114:
                message.type = 114;
                break;
            }
            if (object.shape != null) {
                if (typeof object.shape !== "object")
                    throw TypeError(".tensorflow.AttrValue.shape: object expected");
                message.shape = $root.tensorflow.TensorShape.fromObject(object.shape);
            }
            if (object.tensor != null) {
                if (typeof object.tensor !== "object")
                    throw TypeError(".tensorflow.AttrValue.tensor: object expected");
                message.tensor = $root.tensorflow.Tensor.fromObject(object.tensor);
            }
            if (object.placeholder != null)
                message.placeholder = String(object.placeholder);
            if (object.func != null) {
                if (typeof object.func !== "object")
                    throw TypeError(".tensorflow.AttrValue.func: object expected");
                message.func = $root.tensorflow.NameAttrList.fromObject(object.func);
            }
            return message;
        };

        /**
         * Creates a plain object from an AttrValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.AttrValue
         * @static
         * @param {tensorflow.AttrValue} message AttrValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AttrValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.list != null && message.hasOwnProperty("list")) {
                object.list = $root.tensorflow.AttrValue.ListValue.toObject(message.list, options);
                if (options.oneofs)
                    object.value = "list";
            }
            if (message.s != null && message.hasOwnProperty("s")) {
                object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
                if (options.oneofs)
                    object.value = "s";
            }
            if (message.i != null && message.hasOwnProperty("i")) {
                if (typeof message.i === "number")
                    object.i = options.longs === String ? String(message.i) : message.i;
                else
                    object.i = options.longs === String ? $util.Long.prototype.toString.call(message.i) : options.longs === Number ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber() : message.i;
                if (options.oneofs)
                    object.value = "i";
            }
            if (message.f != null && message.hasOwnProperty("f")) {
                object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;
                if (options.oneofs)
                    object.value = "f";
            }
            if (message.b != null && message.hasOwnProperty("b")) {
                object.b = message.b;
                if (options.oneofs)
                    object.value = "b";
            }
            if (message.type != null && message.hasOwnProperty("type")) {
                object.type = options.enums === String ? $root.tensorflow.DataType[message.type] : message.type;
                if (options.oneofs)
                    object.value = "type";
            }
            if (message.shape != null && message.hasOwnProperty("shape")) {
                object.shape = $root.tensorflow.TensorShape.toObject(message.shape, options);
                if (options.oneofs)
                    object.value = "shape";
            }
            if (message.tensor != null && message.hasOwnProperty("tensor")) {
                object.tensor = $root.tensorflow.Tensor.toObject(message.tensor, options);
                if (options.oneofs)
                    object.value = "tensor";
            }
            if (message.placeholder != null && message.hasOwnProperty("placeholder")) {
                object.placeholder = message.placeholder;
                if (options.oneofs)
                    object.value = "placeholder";
            }
            if (message.func != null && message.hasOwnProperty("func")) {
                object.func = $root.tensorflow.NameAttrList.toObject(message.func, options);
                if (options.oneofs)
                    object.value = "func";
            }
            return object;
        };

        /**
         * Converts this AttrValue to JSON.
         * @function toJSON
         * @memberof tensorflow.AttrValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AttrValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        AttrValue.ListValue = (function() {

            /**
             * Properties of a ListValue.
             * @memberof tensorflow.AttrValue
             * @interface IListValue
             * @property {Array.<Uint8Array>|null} [s] ListValue s
             * @property {Array.<number|Long>|null} [i] ListValue i
             * @property {Array.<number>|null} [f] ListValue f
             * @property {Array.<boolean>|null} [b] ListValue b
             * @property {Array.<tensorflow.DataType>|null} [type] ListValue type
             * @property {Array.<tensorflow.ITensorShape>|null} [shape] ListValue shape
             * @property {Array.<tensorflow.ITensor>|null} [tensor] ListValue tensor
             * @property {Array.<tensorflow.INameAttrList>|null} [func] ListValue func
             */

            /**
             * Constructs a new ListValue.
             * @memberof tensorflow.AttrValue
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {tensorflow.AttrValue.IListValue=} [properties] Properties to set
             */
            function ListValue(properties) {
                this.s = [];
                this.i = [];
                this.f = [];
                this.b = [];
                this.type = [];
                this.shape = [];
                this.tensor = [];
                this.func = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListValue s.
             * @member {Array.<Uint8Array>} s
             * @memberof tensorflow.AttrValue.ListValue
             * @instance
             */
            ListValue.prototype.s = $util.emptyArray;

            /**
             * ListValue i.
             * @member {Array.<number|Long>} i
             * @memberof tensorflow.AttrValue.ListValue
             * @instance
             */
            ListValue.prototype.i = $util.emptyArray;

            /**
             * ListValue f.
             * @member {Array.<number>} f
             * @memberof tensorflow.AttrValue.ListValue
             * @instance
             */
            ListValue.prototype.f = $util.emptyArray;

            /**
             * ListValue b.
             * @member {Array.<boolean>} b
             * @memberof tensorflow.AttrValue.ListValue
             * @instance
             */
            ListValue.prototype.b = $util.emptyArray;

            /**
             * ListValue type.
             * @member {Array.<tensorflow.DataType>} type
             * @memberof tensorflow.AttrValue.ListValue
             * @instance
             */
            ListValue.prototype.type = $util.emptyArray;

            /**
             * ListValue shape.
             * @member {Array.<tensorflow.ITensorShape>} shape
             * @memberof tensorflow.AttrValue.ListValue
             * @instance
             */
            ListValue.prototype.shape = $util.emptyArray;

            /**
             * ListValue tensor.
             * @member {Array.<tensorflow.ITensor>} tensor
             * @memberof tensorflow.AttrValue.ListValue
             * @instance
             */
            ListValue.prototype.tensor = $util.emptyArray;

            /**
             * ListValue func.
             * @member {Array.<tensorflow.INameAttrList>} func
             * @memberof tensorflow.AttrValue.ListValue
             * @instance
             */
            ListValue.prototype.func = $util.emptyArray;

            /**
             * Creates a new ListValue instance using the specified properties.
             * @function create
             * @memberof tensorflow.AttrValue.ListValue
             * @static
             * @param {tensorflow.AttrValue.IListValue=} [properties] Properties to set
             * @returns {tensorflow.AttrValue.ListValue} ListValue instance
             */
            ListValue.create = function create(properties) {
                return new ListValue(properties);
            };

            /**
             * Encodes the specified ListValue message. Does not implicitly {@link tensorflow.AttrValue.ListValue.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.AttrValue.ListValue
             * @static
             * @param {tensorflow.AttrValue.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.s != null && message.s.length)
                    for (var i = 0; i < message.s.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.s[i]);
                if (message.i != null && message.i.length) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork();
                    for (var i = 0; i < message.i.length; ++i)
                        writer.int64(message.i[i]);
                    writer.ldelim();
                }
                if (message.f != null && message.f.length) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork();
                    for (var i = 0; i < message.f.length; ++i)
                        writer.float(message.f[i]);
                    writer.ldelim();
                }
                if (message.b != null && message.b.length) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork();
                    for (var i = 0; i < message.b.length; ++i)
                        writer.bool(message.b[i]);
                    writer.ldelim();
                }
                if (message.type != null && message.type.length) {
                    writer.uint32(/* id 6, wireType 2 =*/50).fork();
                    for (var i = 0; i < message.type.length; ++i)
                        writer.int32(message.type[i]);
                    writer.ldelim();
                }
                if (message.shape != null && message.shape.length)
                    for (var i = 0; i < message.shape.length; ++i)
                        $root.tensorflow.TensorShape.encode(message.shape[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.tensor != null && message.tensor.length)
                    for (var i = 0; i < message.tensor.length; ++i)
                        $root.tensorflow.Tensor.encode(message.tensor[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.func != null && message.func.length)
                    for (var i = 0; i < message.func.length; ++i)
                        $root.tensorflow.NameAttrList.encode(message.func[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListValue message, length delimited. Does not implicitly {@link tensorflow.AttrValue.ListValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.AttrValue.ListValue
             * @static
             * @param {tensorflow.AttrValue.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.AttrValue.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.AttrValue.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.AttrValue.ListValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.s && message.s.length))
                            message.s = [];
                        message.s.push(reader.bytes());
                        break;
                    case 3:
                        if (!(message.i && message.i.length))
                            message.i = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.i.push(reader.int64());
                        } else
                            message.i.push(reader.int64());
                        break;
                    case 4:
                        if (!(message.f && message.f.length))
                            message.f = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.f.push(reader.float());
                        } else
                            message.f.push(reader.float());
                        break;
                    case 5:
                        if (!(message.b && message.b.length))
                            message.b = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.b.push(reader.bool());
                        } else
                            message.b.push(reader.bool());
                        break;
                    case 6:
                        if (!(message.type && message.type.length))
                            message.type = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.type.push(reader.int32());
                        } else
                            message.type.push(reader.int32());
                        break;
                    case 7:
                        if (!(message.shape && message.shape.length))
                            message.shape = [];
                        message.shape.push($root.tensorflow.TensorShape.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.tensor && message.tensor.length))
                            message.tensor = [];
                        message.tensor.push($root.tensorflow.Tensor.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.func && message.func.length))
                            message.func = [];
                        message.func.push($root.tensorflow.NameAttrList.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.AttrValue.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.AttrValue.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof tensorflow.AttrValue.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.s != null && message.hasOwnProperty("s")) {
                    if (!Array.isArray(message.s))
                        return "s: array expected";
                    for (var i = 0; i < message.s.length; ++i)
                        if (!(message.s[i] && typeof message.s[i].length === "number" || $util.isString(message.s[i])))
                            return "s: buffer[] expected";
                }
                if (message.i != null && message.hasOwnProperty("i")) {
                    if (!Array.isArray(message.i))
                        return "i: array expected";
                    for (var i = 0; i < message.i.length; ++i)
                        if (!$util.isInteger(message.i[i]) && !(message.i[i] && $util.isInteger(message.i[i].low) && $util.isInteger(message.i[i].high)))
                            return "i: integer|Long[] expected";
                }
                if (message.f != null && message.hasOwnProperty("f")) {
                    if (!Array.isArray(message.f))
                        return "f: array expected";
                    for (var i = 0; i < message.f.length; ++i)
                        if (typeof message.f[i] !== "number")
                            return "f: number[] expected";
                }
                if (message.b != null && message.hasOwnProperty("b")) {
                    if (!Array.isArray(message.b))
                        return "b: array expected";
                    for (var i = 0; i < message.b.length; ++i)
                        if (typeof message.b[i] !== "boolean")
                            return "b: boolean[] expected";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    if (!Array.isArray(message.type))
                        return "type: array expected";
                    for (var i = 0; i < message.type.length; ++i)
                        switch (message.type[i]) {
                        default:
                            return "type: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 101:
                        case 102:
                        case 103:
                        case 104:
                        case 105:
                        case 106:
                        case 107:
                        case 108:
                        case 109:
                        case 110:
                        case 111:
                        case 112:
                        case 113:
                        case 114:
                            break;
                        }
                }
                if (message.shape != null && message.hasOwnProperty("shape")) {
                    if (!Array.isArray(message.shape))
                        return "shape: array expected";
                    for (var i = 0; i < message.shape.length; ++i) {
                        var error = $root.tensorflow.TensorShape.verify(message.shape[i]);
                        if (error)
                            return "shape." + error;
                    }
                }
                if (message.tensor != null && message.hasOwnProperty("tensor")) {
                    if (!Array.isArray(message.tensor))
                        return "tensor: array expected";
                    for (var i = 0; i < message.tensor.length; ++i) {
                        var error = $root.tensorflow.Tensor.verify(message.tensor[i]);
                        if (error)
                            return "tensor." + error;
                    }
                }
                if (message.func != null && message.hasOwnProperty("func")) {
                    if (!Array.isArray(message.func))
                        return "func: array expected";
                    for (var i = 0; i < message.func.length; ++i) {
                        var error = $root.tensorflow.NameAttrList.verify(message.func[i]);
                        if (error)
                            return "func." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.AttrValue.ListValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.AttrValue.ListValue} ListValue
             */
            ListValue.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.AttrValue.ListValue)
                    return object;
                var message = new $root.tensorflow.AttrValue.ListValue();
                if (object.s) {
                    if (!Array.isArray(object.s))
                        throw TypeError(".tensorflow.AttrValue.ListValue.s: array expected");
                    message.s = [];
                    for (var i = 0; i < object.s.length; ++i)
                        if (typeof object.s[i] === "string")
                            $util.base64.decode(object.s[i], message.s[i] = $util.newBuffer($util.base64.length(object.s[i])), 0);
                        else if (object.s[i].length)
                            message.s[i] = object.s[i];
                }
                if (object.i) {
                    if (!Array.isArray(object.i))
                        throw TypeError(".tensorflow.AttrValue.ListValue.i: array expected");
                    message.i = [];
                    for (var i = 0; i < object.i.length; ++i)
                        if ($util.Long)
                            (message.i[i] = $util.Long.fromValue(object.i[i])).unsigned = false;
                        else if (typeof object.i[i] === "string")
                            message.i[i] = parseInt(object.i[i], 10);
                        else if (typeof object.i[i] === "number")
                            message.i[i] = object.i[i];
                        else if (typeof object.i[i] === "object")
                            message.i[i] = new $util.LongBits(object.i[i].low >>> 0, object.i[i].high >>> 0).toNumber();
                }
                if (object.f) {
                    if (!Array.isArray(object.f))
                        throw TypeError(".tensorflow.AttrValue.ListValue.f: array expected");
                    message.f = [];
                    for (var i = 0; i < object.f.length; ++i)
                        message.f[i] = Number(object.f[i]);
                }
                if (object.b) {
                    if (!Array.isArray(object.b))
                        throw TypeError(".tensorflow.AttrValue.ListValue.b: array expected");
                    message.b = [];
                    for (var i = 0; i < object.b.length; ++i)
                        message.b[i] = Boolean(object.b[i]);
                }
                if (object.type) {
                    if (!Array.isArray(object.type))
                        throw TypeError(".tensorflow.AttrValue.ListValue.type: array expected");
                    message.type = [];
                    for (var i = 0; i < object.type.length; ++i)
                        switch (object.type[i]) {
                        default:
                        case "DT_INVALID":
                        case 0:
                            message.type[i] = 0;
                            break;
                        case "DT_FLOAT":
                        case 1:
                            message.type[i] = 1;
                            break;
                        case "DT_DOUBLE":
                        case 2:
                            message.type[i] = 2;
                            break;
                        case "DT_INT32":
                        case 3:
                            message.type[i] = 3;
                            break;
                        case "DT_UINT8":
                        case 4:
                            message.type[i] = 4;
                            break;
                        case "DT_INT16":
                        case 5:
                            message.type[i] = 5;
                            break;
                        case "DT_INT8":
                        case 6:
                            message.type[i] = 6;
                            break;
                        case "DT_STRING":
                        case 7:
                            message.type[i] = 7;
                            break;
                        case "DT_COMPLEX64":
                        case 8:
                            message.type[i] = 8;
                            break;
                        case "DT_INT64":
                        case 9:
                            message.type[i] = 9;
                            break;
                        case "DT_BOOL":
                        case 10:
                            message.type[i] = 10;
                            break;
                        case "DT_QINT8":
                        case 11:
                            message.type[i] = 11;
                            break;
                        case "DT_QUINT8":
                        case 12:
                            message.type[i] = 12;
                            break;
                        case "DT_QINT32":
                        case 13:
                            message.type[i] = 13;
                            break;
                        case "DT_BFLOAT16":
                        case 14:
                            message.type[i] = 14;
                            break;
                        case "DT_FLOAT_REF":
                        case 101:
                            message.type[i] = 101;
                            break;
                        case "DT_DOUBLE_REF":
                        case 102:
                            message.type[i] = 102;
                            break;
                        case "DT_INT32_REF":
                        case 103:
                            message.type[i] = 103;
                            break;
                        case "DT_UINT8_REF":
                        case 104:
                            message.type[i] = 104;
                            break;
                        case "DT_INT16_REF":
                        case 105:
                            message.type[i] = 105;
                            break;
                        case "DT_INT8_REF":
                        case 106:
                            message.type[i] = 106;
                            break;
                        case "DT_STRING_REF":
                        case 107:
                            message.type[i] = 107;
                            break;
                        case "DT_COMPLEX64_REF":
                        case 108:
                            message.type[i] = 108;
                            break;
                        case "DT_INT64_REF":
                        case 109:
                            message.type[i] = 109;
                            break;
                        case "DT_BOOL_REF":
                        case 110:
                            message.type[i] = 110;
                            break;
                        case "DT_QINT8_REF":
                        case 111:
                            message.type[i] = 111;
                            break;
                        case "DT_QUINT8_REF":
                        case 112:
                            message.type[i] = 112;
                            break;
                        case "DT_QINT32_REF":
                        case 113:
                            message.type[i] = 113;
                            break;
                        case "DT_BFLOAT16_REF":
                        case 114:
                            message.type[i] = 114;
                            break;
                        }
                }
                if (object.shape) {
                    if (!Array.isArray(object.shape))
                        throw TypeError(".tensorflow.AttrValue.ListValue.shape: array expected");
                    message.shape = [];
                    for (var i = 0; i < object.shape.length; ++i) {
                        if (typeof object.shape[i] !== "object")
                            throw TypeError(".tensorflow.AttrValue.ListValue.shape: object expected");
                        message.shape[i] = $root.tensorflow.TensorShape.fromObject(object.shape[i]);
                    }
                }
                if (object.tensor) {
                    if (!Array.isArray(object.tensor))
                        throw TypeError(".tensorflow.AttrValue.ListValue.tensor: array expected");
                    message.tensor = [];
                    for (var i = 0; i < object.tensor.length; ++i) {
                        if (typeof object.tensor[i] !== "object")
                            throw TypeError(".tensorflow.AttrValue.ListValue.tensor: object expected");
                        message.tensor[i] = $root.tensorflow.Tensor.fromObject(object.tensor[i]);
                    }
                }
                if (object.func) {
                    if (!Array.isArray(object.func))
                        throw TypeError(".tensorflow.AttrValue.ListValue.func: array expected");
                    message.func = [];
                    for (var i = 0; i < object.func.length; ++i) {
                        if (typeof object.func[i] !== "object")
                            throw TypeError(".tensorflow.AttrValue.ListValue.func: object expected");
                        message.func[i] = $root.tensorflow.NameAttrList.fromObject(object.func[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.AttrValue.ListValue
             * @static
             * @param {tensorflow.AttrValue.ListValue} message ListValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.s = [];
                    object.i = [];
                    object.f = [];
                    object.b = [];
                    object.type = [];
                    object.shape = [];
                    object.tensor = [];
                    object.func = [];
                }
                if (message.s && message.s.length) {
                    object.s = [];
                    for (var j = 0; j < message.s.length; ++j)
                        object.s[j] = options.bytes === String ? $util.base64.encode(message.s[j], 0, message.s[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.s[j]) : message.s[j];
                }
                if (message.i && message.i.length) {
                    object.i = [];
                    for (var j = 0; j < message.i.length; ++j)
                        if (typeof message.i[j] === "number")
                            object.i[j] = options.longs === String ? String(message.i[j]) : message.i[j];
                        else
                            object.i[j] = options.longs === String ? $util.Long.prototype.toString.call(message.i[j]) : options.longs === Number ? new $util.LongBits(message.i[j].low >>> 0, message.i[j].high >>> 0).toNumber() : message.i[j];
                }
                if (message.f && message.f.length) {
                    object.f = [];
                    for (var j = 0; j < message.f.length; ++j)
                        object.f[j] = options.json && !isFinite(message.f[j]) ? String(message.f[j]) : message.f[j];
                }
                if (message.b && message.b.length) {
                    object.b = [];
                    for (var j = 0; j < message.b.length; ++j)
                        object.b[j] = message.b[j];
                }
                if (message.type && message.type.length) {
                    object.type = [];
                    for (var j = 0; j < message.type.length; ++j)
                        object.type[j] = options.enums === String ? $root.tensorflow.DataType[message.type[j]] : message.type[j];
                }
                if (message.shape && message.shape.length) {
                    object.shape = [];
                    for (var j = 0; j < message.shape.length; ++j)
                        object.shape[j] = $root.tensorflow.TensorShape.toObject(message.shape[j], options);
                }
                if (message.tensor && message.tensor.length) {
                    object.tensor = [];
                    for (var j = 0; j < message.tensor.length; ++j)
                        object.tensor[j] = $root.tensorflow.Tensor.toObject(message.tensor[j], options);
                }
                if (message.func && message.func.length) {
                    object.func = [];
                    for (var j = 0; j < message.func.length; ++j)
                        object.func[j] = $root.tensorflow.NameAttrList.toObject(message.func[j], options);
                }
                return object;
            };

            /**
             * Converts this ListValue to JSON.
             * @function toJSON
             * @memberof tensorflow.AttrValue.ListValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListValue;
        })();

        return AttrValue;
    })();

    tensorflow.NameAttrList = (function() {

        /**
         * Properties of a NameAttrList.
         * @memberof tensorflow
         * @interface INameAttrList
         * @property {string|null} [name] NameAttrList name
         * @property {Object.<string,tensorflow.IAttrValue>|null} [attr] NameAttrList attr
         */

        /**
         * Constructs a new NameAttrList.
         * @memberof tensorflow
         * @classdesc Represents a NameAttrList.
         * @implements INameAttrList
         * @constructor
         * @param {tensorflow.INameAttrList=} [properties] Properties to set
         */
        function NameAttrList(properties) {
            this.attr = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NameAttrList name.
         * @member {string} name
         * @memberof tensorflow.NameAttrList
         * @instance
         */
        NameAttrList.prototype.name = "";

        /**
         * NameAttrList attr.
         * @member {Object.<string,tensorflow.IAttrValue>} attr
         * @memberof tensorflow.NameAttrList
         * @instance
         */
        NameAttrList.prototype.attr = $util.emptyObject;

        /**
         * Creates a new NameAttrList instance using the specified properties.
         * @function create
         * @memberof tensorflow.NameAttrList
         * @static
         * @param {tensorflow.INameAttrList=} [properties] Properties to set
         * @returns {tensorflow.NameAttrList} NameAttrList instance
         */
        NameAttrList.create = function create(properties) {
            return new NameAttrList(properties);
        };

        /**
         * Encodes the specified NameAttrList message. Does not implicitly {@link tensorflow.NameAttrList.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.NameAttrList
         * @static
         * @param {tensorflow.INameAttrList} message NameAttrList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NameAttrList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.attr != null && message.hasOwnProperty("attr"))
                for (var keys = Object.keys(message.attr), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.tensorflow.AttrValue.encode(message.attr[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified NameAttrList message, length delimited. Does not implicitly {@link tensorflow.NameAttrList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.NameAttrList
         * @static
         * @param {tensorflow.INameAttrList} message NameAttrList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NameAttrList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NameAttrList message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.NameAttrList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.NameAttrList} NameAttrList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NameAttrList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.NameAttrList(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    reader.skip().pos++;
                    if (message.attr === $util.emptyObject)
                        message.attr = {};
                    key = reader.string();
                    reader.pos++;
                    message.attr[key] = $root.tensorflow.AttrValue.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NameAttrList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.NameAttrList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.NameAttrList} NameAttrList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NameAttrList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NameAttrList message.
         * @function verify
         * @memberof tensorflow.NameAttrList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NameAttrList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.attr != null && message.hasOwnProperty("attr")) {
                if (!$util.isObject(message.attr))
                    return "attr: object expected";
                var key = Object.keys(message.attr);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.tensorflow.AttrValue.verify(message.attr[key[i]]);
                    if (error)
                        return "attr." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NameAttrList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.NameAttrList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.NameAttrList} NameAttrList
         */
        NameAttrList.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.NameAttrList)
                return object;
            var message = new $root.tensorflow.NameAttrList();
            if (object.name != null)
                message.name = String(object.name);
            if (object.attr) {
                if (typeof object.attr !== "object")
                    throw TypeError(".tensorflow.NameAttrList.attr: object expected");
                message.attr = {};
                for (var keys = Object.keys(object.attr), i = 0; i < keys.length; ++i) {
                    if (typeof object.attr[keys[i]] !== "object")
                        throw TypeError(".tensorflow.NameAttrList.attr: object expected");
                    message.attr[keys[i]] = $root.tensorflow.AttrValue.fromObject(object.attr[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NameAttrList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.NameAttrList
         * @static
         * @param {tensorflow.NameAttrList} message NameAttrList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NameAttrList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.attr = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            var keys2;
            if (message.attr && (keys2 = Object.keys(message.attr)).length) {
                object.attr = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.attr[keys2[j]] = $root.tensorflow.AttrValue.toObject(message.attr[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this NameAttrList to JSON.
         * @function toJSON
         * @memberof tensorflow.NameAttrList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NameAttrList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NameAttrList;
    })();

    tensorflow.NodeDef = (function() {

        /**
         * Properties of a NodeDef.
         * @memberof tensorflow
         * @interface INodeDef
         * @property {string|null} [name] NodeDef name
         * @property {string|null} [op] NodeDef op
         * @property {Array.<string>|null} [input] NodeDef input
         * @property {string|null} [device] NodeDef device
         * @property {Object.<string,tensorflow.IAttrValue>|null} [attr] NodeDef attr
         */

        /**
         * Constructs a new NodeDef.
         * @memberof tensorflow
         * @classdesc Represents a NodeDef.
         * @implements INodeDef
         * @constructor
         * @param {tensorflow.INodeDef=} [properties] Properties to set
         */
        function NodeDef(properties) {
            this.input = [];
            this.attr = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeDef name.
         * @member {string} name
         * @memberof tensorflow.NodeDef
         * @instance
         */
        NodeDef.prototype.name = "";

        /**
         * NodeDef op.
         * @member {string} op
         * @memberof tensorflow.NodeDef
         * @instance
         */
        NodeDef.prototype.op = "";

        /**
         * NodeDef input.
         * @member {Array.<string>} input
         * @memberof tensorflow.NodeDef
         * @instance
         */
        NodeDef.prototype.input = $util.emptyArray;

        /**
         * NodeDef device.
         * @member {string} device
         * @memberof tensorflow.NodeDef
         * @instance
         */
        NodeDef.prototype.device = "";

        /**
         * NodeDef attr.
         * @member {Object.<string,tensorflow.IAttrValue>} attr
         * @memberof tensorflow.NodeDef
         * @instance
         */
        NodeDef.prototype.attr = $util.emptyObject;

        /**
         * Creates a new NodeDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.NodeDef
         * @static
         * @param {tensorflow.INodeDef=} [properties] Properties to set
         * @returns {tensorflow.NodeDef} NodeDef instance
         */
        NodeDef.create = function create(properties) {
            return new NodeDef(properties);
        };

        /**
         * Encodes the specified NodeDef message. Does not implicitly {@link tensorflow.NodeDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.NodeDef
         * @static
         * @param {tensorflow.INodeDef} message NodeDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.op != null && message.hasOwnProperty("op"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.op);
            if (message.input != null && message.input.length)
                for (var i = 0; i < message.input.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.input[i]);
            if (message.device != null && message.hasOwnProperty("device"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.device);
            if (message.attr != null && message.hasOwnProperty("attr"))
                for (var keys = Object.keys(message.attr), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.tensorflow.AttrValue.encode(message.attr[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified NodeDef message, length delimited. Does not implicitly {@link tensorflow.NodeDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.NodeDef
         * @static
         * @param {tensorflow.INodeDef} message NodeDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.NodeDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.NodeDef} NodeDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.NodeDef(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.op = reader.string();
                    break;
                case 3:
                    if (!(message.input && message.input.length))
                        message.input = [];
                    message.input.push(reader.string());
                    break;
                case 4:
                    message.device = reader.string();
                    break;
                case 5:
                    reader.skip().pos++;
                    if (message.attr === $util.emptyObject)
                        message.attr = {};
                    key = reader.string();
                    reader.pos++;
                    message.attr[key] = $root.tensorflow.AttrValue.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.NodeDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.NodeDef} NodeDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeDef message.
         * @function verify
         * @memberof tensorflow.NodeDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.op != null && message.hasOwnProperty("op"))
                if (!$util.isString(message.op))
                    return "op: string expected";
            if (message.input != null && message.hasOwnProperty("input")) {
                if (!Array.isArray(message.input))
                    return "input: array expected";
                for (var i = 0; i < message.input.length; ++i)
                    if (!$util.isString(message.input[i]))
                        return "input: string[] expected";
            }
            if (message.device != null && message.hasOwnProperty("device"))
                if (!$util.isString(message.device))
                    return "device: string expected";
            if (message.attr != null && message.hasOwnProperty("attr")) {
                if (!$util.isObject(message.attr))
                    return "attr: object expected";
                var key = Object.keys(message.attr);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.tensorflow.AttrValue.verify(message.attr[key[i]]);
                    if (error)
                        return "attr." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NodeDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.NodeDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.NodeDef} NodeDef
         */
        NodeDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.NodeDef)
                return object;
            var message = new $root.tensorflow.NodeDef();
            if (object.name != null)
                message.name = String(object.name);
            if (object.op != null)
                message.op = String(object.op);
            if (object.input) {
                if (!Array.isArray(object.input))
                    throw TypeError(".tensorflow.NodeDef.input: array expected");
                message.input = [];
                for (var i = 0; i < object.input.length; ++i)
                    message.input[i] = String(object.input[i]);
            }
            if (object.device != null)
                message.device = String(object.device);
            if (object.attr) {
                if (typeof object.attr !== "object")
                    throw TypeError(".tensorflow.NodeDef.attr: object expected");
                message.attr = {};
                for (var keys = Object.keys(object.attr), i = 0; i < keys.length; ++i) {
                    if (typeof object.attr[keys[i]] !== "object")
                        throw TypeError(".tensorflow.NodeDef.attr: object expected");
                    message.attr[keys[i]] = $root.tensorflow.AttrValue.fromObject(object.attr[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.NodeDef
         * @static
         * @param {tensorflow.NodeDef} message NodeDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.input = [];
            if (options.objects || options.defaults)
                object.attr = {};
            if (options.defaults) {
                object.name = "";
                object.op = "";
                object.device = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.op != null && message.hasOwnProperty("op"))
                object.op = message.op;
            if (message.input && message.input.length) {
                object.input = [];
                for (var j = 0; j < message.input.length; ++j)
                    object.input[j] = message.input[j];
            }
            if (message.device != null && message.hasOwnProperty("device"))
                object.device = message.device;
            var keys2;
            if (message.attr && (keys2 = Object.keys(message.attr)).length) {
                object.attr = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.attr[keys2[j]] = $root.tensorflow.AttrValue.toObject(message.attr[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this NodeDef to JSON.
         * @function toJSON
         * @memberof tensorflow.NodeDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeDef;
    })();

    tensorflow.VersionDef = (function() {

        /**
         * Properties of a VersionDef.
         * @memberof tensorflow
         * @interface IVersionDef
         * @property {number|null} [producer] VersionDef producer
         * @property {number|null} [minConsumer] VersionDef minConsumer
         * @property {Array.<number>|null} [badConsumers] VersionDef badConsumers
         */

        /**
         * Constructs a new VersionDef.
         * @memberof tensorflow
         * @classdesc Represents a VersionDef.
         * @implements IVersionDef
         * @constructor
         * @param {tensorflow.IVersionDef=} [properties] Properties to set
         */
        function VersionDef(properties) {
            this.badConsumers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VersionDef producer.
         * @member {number} producer
         * @memberof tensorflow.VersionDef
         * @instance
         */
        VersionDef.prototype.producer = 0;

        /**
         * VersionDef minConsumer.
         * @member {number} minConsumer
         * @memberof tensorflow.VersionDef
         * @instance
         */
        VersionDef.prototype.minConsumer = 0;

        /**
         * VersionDef badConsumers.
         * @member {Array.<number>} badConsumers
         * @memberof tensorflow.VersionDef
         * @instance
         */
        VersionDef.prototype.badConsumers = $util.emptyArray;

        /**
         * Creates a new VersionDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.VersionDef
         * @static
         * @param {tensorflow.IVersionDef=} [properties] Properties to set
         * @returns {tensorflow.VersionDef} VersionDef instance
         */
        VersionDef.create = function create(properties) {
            return new VersionDef(properties);
        };

        /**
         * Encodes the specified VersionDef message. Does not implicitly {@link tensorflow.VersionDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.VersionDef
         * @static
         * @param {tensorflow.IVersionDef} message VersionDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.producer != null && message.hasOwnProperty("producer"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.producer);
            if (message.minConsumer != null && message.hasOwnProperty("minConsumer"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minConsumer);
            if (message.badConsumers != null && message.badConsumers.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.badConsumers.length; ++i)
                    writer.int32(message.badConsumers[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified VersionDef message, length delimited. Does not implicitly {@link tensorflow.VersionDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.VersionDef
         * @static
         * @param {tensorflow.IVersionDef} message VersionDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VersionDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.VersionDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.VersionDef} VersionDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.VersionDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.producer = reader.int32();
                    break;
                case 2:
                    message.minConsumer = reader.int32();
                    break;
                case 3:
                    if (!(message.badConsumers && message.badConsumers.length))
                        message.badConsumers = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.badConsumers.push(reader.int32());
                    } else
                        message.badConsumers.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VersionDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.VersionDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.VersionDef} VersionDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VersionDef message.
         * @function verify
         * @memberof tensorflow.VersionDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.producer != null && message.hasOwnProperty("producer"))
                if (!$util.isInteger(message.producer))
                    return "producer: integer expected";
            if (message.minConsumer != null && message.hasOwnProperty("minConsumer"))
                if (!$util.isInteger(message.minConsumer))
                    return "minConsumer: integer expected";
            if (message.badConsumers != null && message.hasOwnProperty("badConsumers")) {
                if (!Array.isArray(message.badConsumers))
                    return "badConsumers: array expected";
                for (var i = 0; i < message.badConsumers.length; ++i)
                    if (!$util.isInteger(message.badConsumers[i]))
                        return "badConsumers: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a VersionDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.VersionDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.VersionDef} VersionDef
         */
        VersionDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.VersionDef)
                return object;
            var message = new $root.tensorflow.VersionDef();
            if (object.producer != null)
                message.producer = object.producer | 0;
            if (object.minConsumer != null)
                message.minConsumer = object.minConsumer | 0;
            if (object.badConsumers) {
                if (!Array.isArray(object.badConsumers))
                    throw TypeError(".tensorflow.VersionDef.badConsumers: array expected");
                message.badConsumers = [];
                for (var i = 0; i < object.badConsumers.length; ++i)
                    message.badConsumers[i] = object.badConsumers[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a VersionDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.VersionDef
         * @static
         * @param {tensorflow.VersionDef} message VersionDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.badConsumers = [];
            if (options.defaults) {
                object.producer = 0;
                object.minConsumer = 0;
            }
            if (message.producer != null && message.hasOwnProperty("producer"))
                object.producer = message.producer;
            if (message.minConsumer != null && message.hasOwnProperty("minConsumer"))
                object.minConsumer = message.minConsumer;
            if (message.badConsumers && message.badConsumers.length) {
                object.badConsumers = [];
                for (var j = 0; j < message.badConsumers.length; ++j)
                    object.badConsumers[j] = message.badConsumers[j];
            }
            return object;
        };

        /**
         * Converts this VersionDef to JSON.
         * @function toJSON
         * @memberof tensorflow.VersionDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VersionDef;
    })();

    tensorflow.GraphDef = (function() {

        /**
         * Properties of a GraphDef.
         * @memberof tensorflow
         * @interface IGraphDef
         * @property {Array.<tensorflow.INodeDef>|null} [node] GraphDef node
         * @property {tensorflow.IVersionDef|null} [versions] GraphDef versions
         * @property {tensorflow.IFunctionDefLibrary|null} [library] GraphDef library
         */

        /**
         * Constructs a new GraphDef.
         * @memberof tensorflow
         * @classdesc Represents a GraphDef.
         * @implements IGraphDef
         * @constructor
         * @param {tensorflow.IGraphDef=} [properties] Properties to set
         */
        function GraphDef(properties) {
            this.node = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GraphDef node.
         * @member {Array.<tensorflow.INodeDef>} node
         * @memberof tensorflow.GraphDef
         * @instance
         */
        GraphDef.prototype.node = $util.emptyArray;

        /**
         * GraphDef versions.
         * @member {tensorflow.IVersionDef|null|undefined} versions
         * @memberof tensorflow.GraphDef
         * @instance
         */
        GraphDef.prototype.versions = null;

        /**
         * GraphDef library.
         * @member {tensorflow.IFunctionDefLibrary|null|undefined} library
         * @memberof tensorflow.GraphDef
         * @instance
         */
        GraphDef.prototype.library = null;

        /**
         * Creates a new GraphDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.GraphDef
         * @static
         * @param {tensorflow.IGraphDef=} [properties] Properties to set
         * @returns {tensorflow.GraphDef} GraphDef instance
         */
        GraphDef.create = function create(properties) {
            return new GraphDef(properties);
        };

        /**
         * Encodes the specified GraphDef message. Does not implicitly {@link tensorflow.GraphDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.GraphDef
         * @static
         * @param {tensorflow.IGraphDef} message GraphDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.node != null && message.node.length)
                for (var i = 0; i < message.node.length; ++i)
                    $root.tensorflow.NodeDef.encode(message.node[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.library != null && message.hasOwnProperty("library"))
                $root.tensorflow.FunctionDefLibrary.encode(message.library, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.versions != null && message.hasOwnProperty("versions"))
                $root.tensorflow.VersionDef.encode(message.versions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GraphDef message, length delimited. Does not implicitly {@link tensorflow.GraphDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.GraphDef
         * @static
         * @param {tensorflow.IGraphDef} message GraphDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.GraphDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.GraphDef} GraphDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.GraphDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.node && message.node.length))
                        message.node = [];
                    message.node.push($root.tensorflow.NodeDef.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.versions = $root.tensorflow.VersionDef.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.library = $root.tensorflow.FunctionDefLibrary.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.GraphDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.GraphDef} GraphDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphDef message.
         * @function verify
         * @memberof tensorflow.GraphDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
                if (!Array.isArray(message.node))
                    return "node: array expected";
                for (var i = 0; i < message.node.length; ++i) {
                    var error = $root.tensorflow.NodeDef.verify(message.node[i]);
                    if (error)
                        return "node." + error;
                }
            }
            if (message.versions != null && message.hasOwnProperty("versions")) {
                var error = $root.tensorflow.VersionDef.verify(message.versions);
                if (error)
                    return "versions." + error;
            }
            if (message.library != null && message.hasOwnProperty("library")) {
                var error = $root.tensorflow.FunctionDefLibrary.verify(message.library);
                if (error)
                    return "library." + error;
            }
            return null;
        };

        /**
         * Creates a GraphDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.GraphDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.GraphDef} GraphDef
         */
        GraphDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.GraphDef)
                return object;
            var message = new $root.tensorflow.GraphDef();
            if (object.node) {
                if (!Array.isArray(object.node))
                    throw TypeError(".tensorflow.GraphDef.node: array expected");
                message.node = [];
                for (var i = 0; i < object.node.length; ++i) {
                    if (typeof object.node[i] !== "object")
                        throw TypeError(".tensorflow.GraphDef.node: object expected");
                    message.node[i] = $root.tensorflow.NodeDef.fromObject(object.node[i]);
                }
            }
            if (object.versions != null) {
                if (typeof object.versions !== "object")
                    throw TypeError(".tensorflow.GraphDef.versions: object expected");
                message.versions = $root.tensorflow.VersionDef.fromObject(object.versions);
            }
            if (object.library != null) {
                if (typeof object.library !== "object")
                    throw TypeError(".tensorflow.GraphDef.library: object expected");
                message.library = $root.tensorflow.FunctionDefLibrary.fromObject(object.library);
            }
            return message;
        };

        /**
         * Creates a plain object from a GraphDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.GraphDef
         * @static
         * @param {tensorflow.GraphDef} message GraphDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.node = [];
            if (options.defaults) {
                object.library = null;
                object.versions = null;
            }
            if (message.node && message.node.length) {
                object.node = [];
                for (var j = 0; j < message.node.length; ++j)
                    object.node[j] = $root.tensorflow.NodeDef.toObject(message.node[j], options);
            }
            if (message.library != null && message.hasOwnProperty("library"))
                object.library = $root.tensorflow.FunctionDefLibrary.toObject(message.library, options);
            if (message.versions != null && message.hasOwnProperty("versions"))
                object.versions = $root.tensorflow.VersionDef.toObject(message.versions, options);
            return object;
        };

        /**
         * Converts this GraphDef to JSON.
         * @function toJSON
         * @memberof tensorflow.GraphDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphDef;
    })();

    tensorflow.CollectionDef = (function() {

        /**
         * Properties of a CollectionDef.
         * @memberof tensorflow
         * @interface ICollectionDef
         * @property {tensorflow.CollectionDef.INodeList|null} [nodeList] CollectionDef nodeList
         * @property {tensorflow.CollectionDef.IBytesList|null} [bytesList] CollectionDef bytesList
         * @property {tensorflow.CollectionDef.IInt64List|null} [int64List] CollectionDef int64List
         * @property {tensorflow.CollectionDef.IFloatList|null} [floatList] CollectionDef floatList
         * @property {tensorflow.CollectionDef.IAnyList|null} [anyList] CollectionDef anyList
         */

        /**
         * Constructs a new CollectionDef.
         * @memberof tensorflow
         * @classdesc Represents a CollectionDef.
         * @implements ICollectionDef
         * @constructor
         * @param {tensorflow.ICollectionDef=} [properties] Properties to set
         */
        function CollectionDef(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CollectionDef nodeList.
         * @member {tensorflow.CollectionDef.INodeList|null|undefined} nodeList
         * @memberof tensorflow.CollectionDef
         * @instance
         */
        CollectionDef.prototype.nodeList = null;

        /**
         * CollectionDef bytesList.
         * @member {tensorflow.CollectionDef.IBytesList|null|undefined} bytesList
         * @memberof tensorflow.CollectionDef
         * @instance
         */
        CollectionDef.prototype.bytesList = null;

        /**
         * CollectionDef int64List.
         * @member {tensorflow.CollectionDef.IInt64List|null|undefined} int64List
         * @memberof tensorflow.CollectionDef
         * @instance
         */
        CollectionDef.prototype.int64List = null;

        /**
         * CollectionDef floatList.
         * @member {tensorflow.CollectionDef.IFloatList|null|undefined} floatList
         * @memberof tensorflow.CollectionDef
         * @instance
         */
        CollectionDef.prototype.floatList = null;

        /**
         * CollectionDef anyList.
         * @member {tensorflow.CollectionDef.IAnyList|null|undefined} anyList
         * @memberof tensorflow.CollectionDef
         * @instance
         */
        CollectionDef.prototype.anyList = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * CollectionDef kind.
         * @member {"nodeList"|"bytesList"|"int64List"|"floatList"|"anyList"|undefined} kind
         * @memberof tensorflow.CollectionDef
         * @instance
         */
        Object.defineProperty(CollectionDef.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["nodeList", "bytesList", "int64List", "floatList", "anyList"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CollectionDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.CollectionDef
         * @static
         * @param {tensorflow.ICollectionDef=} [properties] Properties to set
         * @returns {tensorflow.CollectionDef} CollectionDef instance
         */
        CollectionDef.create = function create(properties) {
            return new CollectionDef(properties);
        };

        /**
         * Encodes the specified CollectionDef message. Does not implicitly {@link tensorflow.CollectionDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.CollectionDef
         * @static
         * @param {tensorflow.ICollectionDef} message CollectionDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CollectionDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeList != null && message.hasOwnProperty("nodeList"))
                $root.tensorflow.CollectionDef.NodeList.encode(message.nodeList, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.bytesList != null && message.hasOwnProperty("bytesList"))
                $root.tensorflow.CollectionDef.BytesList.encode(message.bytesList, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.int64List != null && message.hasOwnProperty("int64List"))
                $root.tensorflow.CollectionDef.Int64List.encode(message.int64List, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.floatList != null && message.hasOwnProperty("floatList"))
                $root.tensorflow.CollectionDef.FloatList.encode(message.floatList, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.anyList != null && message.hasOwnProperty("anyList"))
                $root.tensorflow.CollectionDef.AnyList.encode(message.anyList, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CollectionDef message, length delimited. Does not implicitly {@link tensorflow.CollectionDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.CollectionDef
         * @static
         * @param {tensorflow.ICollectionDef} message CollectionDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CollectionDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CollectionDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.CollectionDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.CollectionDef} CollectionDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CollectionDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.CollectionDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nodeList = $root.tensorflow.CollectionDef.NodeList.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.bytesList = $root.tensorflow.CollectionDef.BytesList.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.int64List = $root.tensorflow.CollectionDef.Int64List.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.floatList = $root.tensorflow.CollectionDef.FloatList.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.anyList = $root.tensorflow.CollectionDef.AnyList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CollectionDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.CollectionDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.CollectionDef} CollectionDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CollectionDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CollectionDef message.
         * @function verify
         * @memberof tensorflow.CollectionDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CollectionDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.nodeList != null && message.hasOwnProperty("nodeList")) {
                properties.kind = 1;
                {
                    var error = $root.tensorflow.CollectionDef.NodeList.verify(message.nodeList);
                    if (error)
                        return "nodeList." + error;
                }
            }
            if (message.bytesList != null && message.hasOwnProperty("bytesList")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.tensorflow.CollectionDef.BytesList.verify(message.bytesList);
                    if (error)
                        return "bytesList." + error;
                }
            }
            if (message.int64List != null && message.hasOwnProperty("int64List")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.tensorflow.CollectionDef.Int64List.verify(message.int64List);
                    if (error)
                        return "int64List." + error;
                }
            }
            if (message.floatList != null && message.hasOwnProperty("floatList")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.tensorflow.CollectionDef.FloatList.verify(message.floatList);
                    if (error)
                        return "floatList." + error;
                }
            }
            if (message.anyList != null && message.hasOwnProperty("anyList")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.tensorflow.CollectionDef.AnyList.verify(message.anyList);
                    if (error)
                        return "anyList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CollectionDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.CollectionDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.CollectionDef} CollectionDef
         */
        CollectionDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.CollectionDef)
                return object;
            var message = new $root.tensorflow.CollectionDef();
            if (object.nodeList != null) {
                if (typeof object.nodeList !== "object")
                    throw TypeError(".tensorflow.CollectionDef.nodeList: object expected");
                message.nodeList = $root.tensorflow.CollectionDef.NodeList.fromObject(object.nodeList);
            }
            if (object.bytesList != null) {
                if (typeof object.bytesList !== "object")
                    throw TypeError(".tensorflow.CollectionDef.bytesList: object expected");
                message.bytesList = $root.tensorflow.CollectionDef.BytesList.fromObject(object.bytesList);
            }
            if (object.int64List != null) {
                if (typeof object.int64List !== "object")
                    throw TypeError(".tensorflow.CollectionDef.int64List: object expected");
                message.int64List = $root.tensorflow.CollectionDef.Int64List.fromObject(object.int64List);
            }
            if (object.floatList != null) {
                if (typeof object.floatList !== "object")
                    throw TypeError(".tensorflow.CollectionDef.floatList: object expected");
                message.floatList = $root.tensorflow.CollectionDef.FloatList.fromObject(object.floatList);
            }
            if (object.anyList != null) {
                if (typeof object.anyList !== "object")
                    throw TypeError(".tensorflow.CollectionDef.anyList: object expected");
                message.anyList = $root.tensorflow.CollectionDef.AnyList.fromObject(object.anyList);
            }
            return message;
        };

        /**
         * Creates a plain object from a CollectionDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.CollectionDef
         * @static
         * @param {tensorflow.CollectionDef} message CollectionDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CollectionDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.nodeList != null && message.hasOwnProperty("nodeList")) {
                object.nodeList = $root.tensorflow.CollectionDef.NodeList.toObject(message.nodeList, options);
                if (options.oneofs)
                    object.kind = "nodeList";
            }
            if (message.bytesList != null && message.hasOwnProperty("bytesList")) {
                object.bytesList = $root.tensorflow.CollectionDef.BytesList.toObject(message.bytesList, options);
                if (options.oneofs)
                    object.kind = "bytesList";
            }
            if (message.int64List != null && message.hasOwnProperty("int64List")) {
                object.int64List = $root.tensorflow.CollectionDef.Int64List.toObject(message.int64List, options);
                if (options.oneofs)
                    object.kind = "int64List";
            }
            if (message.floatList != null && message.hasOwnProperty("floatList")) {
                object.floatList = $root.tensorflow.CollectionDef.FloatList.toObject(message.floatList, options);
                if (options.oneofs)
                    object.kind = "floatList";
            }
            if (message.anyList != null && message.hasOwnProperty("anyList")) {
                object.anyList = $root.tensorflow.CollectionDef.AnyList.toObject(message.anyList, options);
                if (options.oneofs)
                    object.kind = "anyList";
            }
            return object;
        };

        /**
         * Converts this CollectionDef to JSON.
         * @function toJSON
         * @memberof tensorflow.CollectionDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CollectionDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        CollectionDef.NodeList = (function() {

            /**
             * Properties of a NodeList.
             * @memberof tensorflow.CollectionDef
             * @interface INodeList
             * @property {Array.<string>|null} [value] NodeList value
             */

            /**
             * Constructs a new NodeList.
             * @memberof tensorflow.CollectionDef
             * @classdesc Represents a NodeList.
             * @implements INodeList
             * @constructor
             * @param {tensorflow.CollectionDef.INodeList=} [properties] Properties to set
             */
            function NodeList(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeList value.
             * @member {Array.<string>} value
             * @memberof tensorflow.CollectionDef.NodeList
             * @instance
             */
            NodeList.prototype.value = $util.emptyArray;

            /**
             * Creates a new NodeList instance using the specified properties.
             * @function create
             * @memberof tensorflow.CollectionDef.NodeList
             * @static
             * @param {tensorflow.CollectionDef.INodeList=} [properties] Properties to set
             * @returns {tensorflow.CollectionDef.NodeList} NodeList instance
             */
            NodeList.create = function create(properties) {
                return new NodeList(properties);
            };

            /**
             * Encodes the specified NodeList message. Does not implicitly {@link tensorflow.CollectionDef.NodeList.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.CollectionDef.NodeList
             * @static
             * @param {tensorflow.CollectionDef.INodeList} message NodeList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value[i]);
                return writer;
            };

            /**
             * Encodes the specified NodeList message, length delimited. Does not implicitly {@link tensorflow.CollectionDef.NodeList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.CollectionDef.NodeList
             * @static
             * @param {tensorflow.CollectionDef.INodeList} message NodeList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NodeList message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.CollectionDef.NodeList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.CollectionDef.NodeList} NodeList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.CollectionDef.NodeList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NodeList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.CollectionDef.NodeList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.CollectionDef.NodeList} NodeList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NodeList message.
             * @function verify
             * @memberof tensorflow.CollectionDef.NodeList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i)
                        if (!$util.isString(message.value[i]))
                            return "value: string[] expected";
                }
                return null;
            };

            /**
             * Creates a NodeList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.CollectionDef.NodeList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.CollectionDef.NodeList} NodeList
             */
            NodeList.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.CollectionDef.NodeList)
                    return object;
                var message = new $root.tensorflow.CollectionDef.NodeList();
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".tensorflow.CollectionDef.NodeList.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i)
                        message.value[i] = String(object.value[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a NodeList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.CollectionDef.NodeList
             * @static
             * @param {tensorflow.CollectionDef.NodeList} message NodeList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = message.value[j];
                }
                return object;
            };

            /**
             * Converts this NodeList to JSON.
             * @function toJSON
             * @memberof tensorflow.CollectionDef.NodeList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NodeList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NodeList;
        })();

        CollectionDef.BytesList = (function() {

            /**
             * Properties of a BytesList.
             * @memberof tensorflow.CollectionDef
             * @interface IBytesList
             * @property {Array.<Uint8Array>|null} [value] BytesList value
             */

            /**
             * Constructs a new BytesList.
             * @memberof tensorflow.CollectionDef
             * @classdesc Represents a BytesList.
             * @implements IBytesList
             * @constructor
             * @param {tensorflow.CollectionDef.IBytesList=} [properties] Properties to set
             */
            function BytesList(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BytesList value.
             * @member {Array.<Uint8Array>} value
             * @memberof tensorflow.CollectionDef.BytesList
             * @instance
             */
            BytesList.prototype.value = $util.emptyArray;

            /**
             * Creates a new BytesList instance using the specified properties.
             * @function create
             * @memberof tensorflow.CollectionDef.BytesList
             * @static
             * @param {tensorflow.CollectionDef.IBytesList=} [properties] Properties to set
             * @returns {tensorflow.CollectionDef.BytesList} BytesList instance
             */
            BytesList.create = function create(properties) {
                return new BytesList(properties);
            };

            /**
             * Encodes the specified BytesList message. Does not implicitly {@link tensorflow.CollectionDef.BytesList.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.CollectionDef.BytesList
             * @static
             * @param {tensorflow.CollectionDef.IBytesList} message BytesList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value[i]);
                return writer;
            };

            /**
             * Encodes the specified BytesList message, length delimited. Does not implicitly {@link tensorflow.CollectionDef.BytesList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.CollectionDef.BytesList
             * @static
             * @param {tensorflow.CollectionDef.IBytesList} message BytesList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BytesList message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.CollectionDef.BytesList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.CollectionDef.BytesList} BytesList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.CollectionDef.BytesList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BytesList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.CollectionDef.BytesList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.CollectionDef.BytesList} BytesList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BytesList message.
             * @function verify
             * @memberof tensorflow.CollectionDef.BytesList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BytesList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i)
                        if (!(message.value[i] && typeof message.value[i].length === "number" || $util.isString(message.value[i])))
                            return "value: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates a BytesList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.CollectionDef.BytesList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.CollectionDef.BytesList} BytesList
             */
            BytesList.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.CollectionDef.BytesList)
                    return object;
                var message = new $root.tensorflow.CollectionDef.BytesList();
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".tensorflow.CollectionDef.BytesList.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i)
                        if (typeof object.value[i] === "string")
                            $util.base64.decode(object.value[i], message.value[i] = $util.newBuffer($util.base64.length(object.value[i])), 0);
                        else if (object.value[i].length)
                            message.value[i] = object.value[i];
                }
                return message;
            };

            /**
             * Creates a plain object from a BytesList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.CollectionDef.BytesList
             * @static
             * @param {tensorflow.CollectionDef.BytesList} message BytesList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BytesList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = options.bytes === String ? $util.base64.encode(message.value[j], 0, message.value[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.value[j]) : message.value[j];
                }
                return object;
            };

            /**
             * Converts this BytesList to JSON.
             * @function toJSON
             * @memberof tensorflow.CollectionDef.BytesList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BytesList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BytesList;
        })();

        CollectionDef.Int64List = (function() {

            /**
             * Properties of an Int64List.
             * @memberof tensorflow.CollectionDef
             * @interface IInt64List
             * @property {Array.<number|Long>|null} [value] Int64List value
             */

            /**
             * Constructs a new Int64List.
             * @memberof tensorflow.CollectionDef
             * @classdesc Represents an Int64List.
             * @implements IInt64List
             * @constructor
             * @param {tensorflow.CollectionDef.IInt64List=} [properties] Properties to set
             */
            function Int64List(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int64List value.
             * @member {Array.<number|Long>} value
             * @memberof tensorflow.CollectionDef.Int64List
             * @instance
             */
            Int64List.prototype.value = $util.emptyArray;

            /**
             * Creates a new Int64List instance using the specified properties.
             * @function create
             * @memberof tensorflow.CollectionDef.Int64List
             * @static
             * @param {tensorflow.CollectionDef.IInt64List=} [properties] Properties to set
             * @returns {tensorflow.CollectionDef.Int64List} Int64List instance
             */
            Int64List.create = function create(properties) {
                return new Int64List(properties);
            };

            /**
             * Encodes the specified Int64List message. Does not implicitly {@link tensorflow.CollectionDef.Int64List.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.CollectionDef.Int64List
             * @static
             * @param {tensorflow.CollectionDef.IInt64List} message Int64List message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64List.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.value.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.value.length; ++i)
                        writer.int64(message.value[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified Int64List message, length delimited. Does not implicitly {@link tensorflow.CollectionDef.Int64List.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.CollectionDef.Int64List
             * @static
             * @param {tensorflow.CollectionDef.IInt64List} message Int64List message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64List.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Int64List message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.CollectionDef.Int64List
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.CollectionDef.Int64List} Int64List
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64List.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.CollectionDef.Int64List();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.value.push(reader.int64());
                        } else
                            message.value.push(reader.int64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Int64List message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.CollectionDef.Int64List
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.CollectionDef.Int64List} Int64List
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64List.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Int64List message.
             * @function verify
             * @memberof tensorflow.CollectionDef.Int64List
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int64List.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i)
                        if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))
                            return "value: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates an Int64List message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.CollectionDef.Int64List
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.CollectionDef.Int64List} Int64List
             */
            Int64List.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.CollectionDef.Int64List)
                    return object;
                var message = new $root.tensorflow.CollectionDef.Int64List();
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".tensorflow.CollectionDef.Int64List.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i)
                        if ($util.Long)
                            (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = false;
                        else if (typeof object.value[i] === "string")
                            message.value[i] = parseInt(object.value[i], 10);
                        else if (typeof object.value[i] === "number")
                            message.value[i] = object.value[i];
                        else if (typeof object.value[i] === "object")
                            message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber();
                }
                return message;
            };

            /**
             * Creates a plain object from an Int64List message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.CollectionDef.Int64List
             * @static
             * @param {tensorflow.CollectionDef.Int64List} message Int64List
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int64List.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        if (typeof message.value[j] === "number")
                            object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];
                        else
                            object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber() : message.value[j];
                }
                return object;
            };

            /**
             * Converts this Int64List to JSON.
             * @function toJSON
             * @memberof tensorflow.CollectionDef.Int64List
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int64List.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Int64List;
        })();

        CollectionDef.FloatList = (function() {

            /**
             * Properties of a FloatList.
             * @memberof tensorflow.CollectionDef
             * @interface IFloatList
             * @property {Array.<number>|null} [value] FloatList value
             */

            /**
             * Constructs a new FloatList.
             * @memberof tensorflow.CollectionDef
             * @classdesc Represents a FloatList.
             * @implements IFloatList
             * @constructor
             * @param {tensorflow.CollectionDef.IFloatList=} [properties] Properties to set
             */
            function FloatList(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FloatList value.
             * @member {Array.<number>} value
             * @memberof tensorflow.CollectionDef.FloatList
             * @instance
             */
            FloatList.prototype.value = $util.emptyArray;

            /**
             * Creates a new FloatList instance using the specified properties.
             * @function create
             * @memberof tensorflow.CollectionDef.FloatList
             * @static
             * @param {tensorflow.CollectionDef.IFloatList=} [properties] Properties to set
             * @returns {tensorflow.CollectionDef.FloatList} FloatList instance
             */
            FloatList.create = function create(properties) {
                return new FloatList(properties);
            };

            /**
             * Encodes the specified FloatList message. Does not implicitly {@link tensorflow.CollectionDef.FloatList.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.CollectionDef.FloatList
             * @static
             * @param {tensorflow.CollectionDef.IFloatList} message FloatList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.value.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.value.length; ++i)
                        writer.float(message.value[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified FloatList message, length delimited. Does not implicitly {@link tensorflow.CollectionDef.FloatList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.CollectionDef.FloatList
             * @static
             * @param {tensorflow.CollectionDef.IFloatList} message FloatList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FloatList message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.CollectionDef.FloatList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.CollectionDef.FloatList} FloatList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.CollectionDef.FloatList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.value.push(reader.float());
                        } else
                            message.value.push(reader.float());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FloatList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.CollectionDef.FloatList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.CollectionDef.FloatList} FloatList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FloatList message.
             * @function verify
             * @memberof tensorflow.CollectionDef.FloatList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FloatList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i)
                        if (typeof message.value[i] !== "number")
                            return "value: number[] expected";
                }
                return null;
            };

            /**
             * Creates a FloatList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.CollectionDef.FloatList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.CollectionDef.FloatList} FloatList
             */
            FloatList.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.CollectionDef.FloatList)
                    return object;
                var message = new $root.tensorflow.CollectionDef.FloatList();
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".tensorflow.CollectionDef.FloatList.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i)
                        message.value[i] = Number(object.value[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a FloatList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.CollectionDef.FloatList
             * @static
             * @param {tensorflow.CollectionDef.FloatList} message FloatList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FloatList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = options.json && !isFinite(message.value[j]) ? String(message.value[j]) : message.value[j];
                }
                return object;
            };

            /**
             * Converts this FloatList to JSON.
             * @function toJSON
             * @memberof tensorflow.CollectionDef.FloatList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FloatList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FloatList;
        })();

        CollectionDef.AnyList = (function() {

            /**
             * Properties of an AnyList.
             * @memberof tensorflow.CollectionDef
             * @interface IAnyList
             * @property {Array.<tensorflow.IAny>|null} [value] AnyList value
             */

            /**
             * Constructs a new AnyList.
             * @memberof tensorflow.CollectionDef
             * @classdesc Represents an AnyList.
             * @implements IAnyList
             * @constructor
             * @param {tensorflow.CollectionDef.IAnyList=} [properties] Properties to set
             */
            function AnyList(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AnyList value.
             * @member {Array.<tensorflow.IAny>} value
             * @memberof tensorflow.CollectionDef.AnyList
             * @instance
             */
            AnyList.prototype.value = $util.emptyArray;

            /**
             * Creates a new AnyList instance using the specified properties.
             * @function create
             * @memberof tensorflow.CollectionDef.AnyList
             * @static
             * @param {tensorflow.CollectionDef.IAnyList=} [properties] Properties to set
             * @returns {tensorflow.CollectionDef.AnyList} AnyList instance
             */
            AnyList.create = function create(properties) {
                return new AnyList(properties);
            };

            /**
             * Encodes the specified AnyList message. Does not implicitly {@link tensorflow.CollectionDef.AnyList.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.CollectionDef.AnyList
             * @static
             * @param {tensorflow.CollectionDef.IAnyList} message AnyList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnyList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        $root.tensorflow.Any.encode(message.value[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AnyList message, length delimited. Does not implicitly {@link tensorflow.CollectionDef.AnyList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.CollectionDef.AnyList
             * @static
             * @param {tensorflow.CollectionDef.IAnyList} message AnyList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnyList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AnyList message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.CollectionDef.AnyList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.CollectionDef.AnyList} AnyList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnyList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.CollectionDef.AnyList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.tensorflow.Any.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AnyList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.CollectionDef.AnyList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.CollectionDef.AnyList} AnyList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnyList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AnyList message.
             * @function verify
             * @memberof tensorflow.CollectionDef.AnyList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnyList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i) {
                        var error = $root.tensorflow.Any.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an AnyList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.CollectionDef.AnyList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.CollectionDef.AnyList} AnyList
             */
            AnyList.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.CollectionDef.AnyList)
                    return object;
                var message = new $root.tensorflow.CollectionDef.AnyList();
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".tensorflow.CollectionDef.AnyList.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".tensorflow.CollectionDef.AnyList.value: object expected");
                        message.value[i] = $root.tensorflow.Any.fromObject(object.value[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an AnyList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.CollectionDef.AnyList
             * @static
             * @param {tensorflow.CollectionDef.AnyList} message AnyList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnyList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.tensorflow.Any.toObject(message.value[j], options);
                }
                return object;
            };

            /**
             * Converts this AnyList to JSON.
             * @function toJSON
             * @memberof tensorflow.CollectionDef.AnyList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnyList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AnyList;
        })();

        return CollectionDef;
    })();

    tensorflow.SaverDef = (function() {

        /**
         * Properties of a SaverDef.
         * @memberof tensorflow
         * @interface ISaverDef
         * @property {string|null} [filenameTensorName] SaverDef filenameTensorName
         * @property {string|null} [saveTensorName] SaverDef saveTensorName
         * @property {string|null} [restoreOpName] SaverDef restoreOpName
         * @property {number|null} [maxToKeep] SaverDef maxToKeep
         * @property {boolean|null} [sharded] SaverDef sharded
         * @property {number|null} [keepCheckpointEveryNHours] SaverDef keepCheckpointEveryNHours
         * @property {tensorflow.SaverDef.CheckpointFormatVersion|null} [version] SaverDef version
         */

        /**
         * Constructs a new SaverDef.
         * @memberof tensorflow
         * @classdesc Represents a SaverDef.
         * @implements ISaverDef
         * @constructor
         * @param {tensorflow.ISaverDef=} [properties] Properties to set
         */
        function SaverDef(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SaverDef filenameTensorName.
         * @member {string} filenameTensorName
         * @memberof tensorflow.SaverDef
         * @instance
         */
        SaverDef.prototype.filenameTensorName = "";

        /**
         * SaverDef saveTensorName.
         * @member {string} saveTensorName
         * @memberof tensorflow.SaverDef
         * @instance
         */
        SaverDef.prototype.saveTensorName = "";

        /**
         * SaverDef restoreOpName.
         * @member {string} restoreOpName
         * @memberof tensorflow.SaverDef
         * @instance
         */
        SaverDef.prototype.restoreOpName = "";

        /**
         * SaverDef maxToKeep.
         * @member {number} maxToKeep
         * @memberof tensorflow.SaverDef
         * @instance
         */
        SaverDef.prototype.maxToKeep = 0;

        /**
         * SaverDef sharded.
         * @member {boolean} sharded
         * @memberof tensorflow.SaverDef
         * @instance
         */
        SaverDef.prototype.sharded = false;

        /**
         * SaverDef keepCheckpointEveryNHours.
         * @member {number} keepCheckpointEveryNHours
         * @memberof tensorflow.SaverDef
         * @instance
         */
        SaverDef.prototype.keepCheckpointEveryNHours = 0;

        /**
         * SaverDef version.
         * @member {tensorflow.SaverDef.CheckpointFormatVersion} version
         * @memberof tensorflow.SaverDef
         * @instance
         */
        SaverDef.prototype.version = 0;

        /**
         * Creates a new SaverDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.SaverDef
         * @static
         * @param {tensorflow.ISaverDef=} [properties] Properties to set
         * @returns {tensorflow.SaverDef} SaverDef instance
         */
        SaverDef.create = function create(properties) {
            return new SaverDef(properties);
        };

        /**
         * Encodes the specified SaverDef message. Does not implicitly {@link tensorflow.SaverDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.SaverDef
         * @static
         * @param {tensorflow.ISaverDef} message SaverDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SaverDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filenameTensorName != null && message.hasOwnProperty("filenameTensorName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.filenameTensorName);
            if (message.saveTensorName != null && message.hasOwnProperty("saveTensorName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.saveTensorName);
            if (message.restoreOpName != null && message.hasOwnProperty("restoreOpName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.restoreOpName);
            if (message.maxToKeep != null && message.hasOwnProperty("maxToKeep"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maxToKeep);
            if (message.sharded != null && message.hasOwnProperty("sharded"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.sharded);
            if (message.keepCheckpointEveryNHours != null && message.hasOwnProperty("keepCheckpointEveryNHours"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.keepCheckpointEveryNHours);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.version);
            return writer;
        };

        /**
         * Encodes the specified SaverDef message, length delimited. Does not implicitly {@link tensorflow.SaverDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.SaverDef
         * @static
         * @param {tensorflow.ISaverDef} message SaverDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SaverDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SaverDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.SaverDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.SaverDef} SaverDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SaverDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.SaverDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.filenameTensorName = reader.string();
                    break;
                case 2:
                    message.saveTensorName = reader.string();
                    break;
                case 3:
                    message.restoreOpName = reader.string();
                    break;
                case 4:
                    message.maxToKeep = reader.int32();
                    break;
                case 5:
                    message.sharded = reader.bool();
                    break;
                case 6:
                    message.keepCheckpointEveryNHours = reader.float();
                    break;
                case 7:
                    message.version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SaverDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.SaverDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.SaverDef} SaverDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SaverDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SaverDef message.
         * @function verify
         * @memberof tensorflow.SaverDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SaverDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.filenameTensorName != null && message.hasOwnProperty("filenameTensorName"))
                if (!$util.isString(message.filenameTensorName))
                    return "filenameTensorName: string expected";
            if (message.saveTensorName != null && message.hasOwnProperty("saveTensorName"))
                if (!$util.isString(message.saveTensorName))
                    return "saveTensorName: string expected";
            if (message.restoreOpName != null && message.hasOwnProperty("restoreOpName"))
                if (!$util.isString(message.restoreOpName))
                    return "restoreOpName: string expected";
            if (message.maxToKeep != null && message.hasOwnProperty("maxToKeep"))
                if (!$util.isInteger(message.maxToKeep))
                    return "maxToKeep: integer expected";
            if (message.sharded != null && message.hasOwnProperty("sharded"))
                if (typeof message.sharded !== "boolean")
                    return "sharded: boolean expected";
            if (message.keepCheckpointEveryNHours != null && message.hasOwnProperty("keepCheckpointEveryNHours"))
                if (typeof message.keepCheckpointEveryNHours !== "number")
                    return "keepCheckpointEveryNHours: number expected";
            if (message.version != null && message.hasOwnProperty("version"))
                switch (message.version) {
                default:
                    return "version: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a SaverDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.SaverDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.SaverDef} SaverDef
         */
        SaverDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.SaverDef)
                return object;
            var message = new $root.tensorflow.SaverDef();
            if (object.filenameTensorName != null)
                message.filenameTensorName = String(object.filenameTensorName);
            if (object.saveTensorName != null)
                message.saveTensorName = String(object.saveTensorName);
            if (object.restoreOpName != null)
                message.restoreOpName = String(object.restoreOpName);
            if (object.maxToKeep != null)
                message.maxToKeep = object.maxToKeep | 0;
            if (object.sharded != null)
                message.sharded = Boolean(object.sharded);
            if (object.keepCheckpointEveryNHours != null)
                message.keepCheckpointEveryNHours = Number(object.keepCheckpointEveryNHours);
            switch (object.version) {
            case "LEGACY":
            case 0:
                message.version = 0;
                break;
            case "V1":
            case 1:
                message.version = 1;
                break;
            case "V2":
            case 2:
                message.version = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SaverDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.SaverDef
         * @static
         * @param {tensorflow.SaverDef} message SaverDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SaverDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.filenameTensorName = "";
                object.saveTensorName = "";
                object.restoreOpName = "";
                object.maxToKeep = 0;
                object.sharded = false;
                object.keepCheckpointEveryNHours = 0;
                object.version = options.enums === String ? "LEGACY" : 0;
            }
            if (message.filenameTensorName != null && message.hasOwnProperty("filenameTensorName"))
                object.filenameTensorName = message.filenameTensorName;
            if (message.saveTensorName != null && message.hasOwnProperty("saveTensorName"))
                object.saveTensorName = message.saveTensorName;
            if (message.restoreOpName != null && message.hasOwnProperty("restoreOpName"))
                object.restoreOpName = message.restoreOpName;
            if (message.maxToKeep != null && message.hasOwnProperty("maxToKeep"))
                object.maxToKeep = message.maxToKeep;
            if (message.sharded != null && message.hasOwnProperty("sharded"))
                object.sharded = message.sharded;
            if (message.keepCheckpointEveryNHours != null && message.hasOwnProperty("keepCheckpointEveryNHours"))
                object.keepCheckpointEveryNHours = options.json && !isFinite(message.keepCheckpointEveryNHours) ? String(message.keepCheckpointEveryNHours) : message.keepCheckpointEveryNHours;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = options.enums === String ? $root.tensorflow.SaverDef.CheckpointFormatVersion[message.version] : message.version;
            return object;
        };

        /**
         * Converts this SaverDef to JSON.
         * @function toJSON
         * @memberof tensorflow.SaverDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SaverDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * CheckpointFormatVersion enum.
         * @name tensorflow.SaverDef.CheckpointFormatVersion
         * @enum {string}
         * @property {number} LEGACY=0 LEGACY value
         * @property {number} V1=1 V1 value
         * @property {number} V2=2 V2 value
         */
        SaverDef.CheckpointFormatVersion = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LEGACY"] = 0;
            values[valuesById[1] = "V1"] = 1;
            values[valuesById[2] = "V2"] = 2;
            return values;
        })();

        return SaverDef;
    })();

    tensorflow.TensorInfo = (function() {

        /**
         * Properties of a TensorInfo.
         * @memberof tensorflow
         * @interface ITensorInfo
         * @property {string|null} [name] TensorInfo name
         * @property {tensorflow.TensorInfo.ICooSparse|null} [cooSparse] TensorInfo cooSparse
         * @property {tensorflow.DataType|null} [dtype] TensorInfo dtype
         * @property {tensorflow.ITensorShape|null} [tensorShape] TensorInfo tensorShape
         */

        /**
         * Constructs a new TensorInfo.
         * @memberof tensorflow
         * @classdesc Represents a TensorInfo.
         * @implements ITensorInfo
         * @constructor
         * @param {tensorflow.ITensorInfo=} [properties] Properties to set
         */
        function TensorInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TensorInfo name.
         * @member {string} name
         * @memberof tensorflow.TensorInfo
         * @instance
         */
        TensorInfo.prototype.name = "";

        /**
         * TensorInfo cooSparse.
         * @member {tensorflow.TensorInfo.ICooSparse|null|undefined} cooSparse
         * @memberof tensorflow.TensorInfo
         * @instance
         */
        TensorInfo.prototype.cooSparse = null;

        /**
         * TensorInfo dtype.
         * @member {tensorflow.DataType} dtype
         * @memberof tensorflow.TensorInfo
         * @instance
         */
        TensorInfo.prototype.dtype = 0;

        /**
         * TensorInfo tensorShape.
         * @member {tensorflow.ITensorShape|null|undefined} tensorShape
         * @memberof tensorflow.TensorInfo
         * @instance
         */
        TensorInfo.prototype.tensorShape = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * TensorInfo encoding.
         * @member {"name"|"cooSparse"|undefined} encoding
         * @memberof tensorflow.TensorInfo
         * @instance
         */
        Object.defineProperty(TensorInfo.prototype, "encoding", {
            get: $util.oneOfGetter($oneOfFields = ["name", "cooSparse"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TensorInfo instance using the specified properties.
         * @function create
         * @memberof tensorflow.TensorInfo
         * @static
         * @param {tensorflow.ITensorInfo=} [properties] Properties to set
         * @returns {tensorflow.TensorInfo} TensorInfo instance
         */
        TensorInfo.create = function create(properties) {
            return new TensorInfo(properties);
        };

        /**
         * Encodes the specified TensorInfo message. Does not implicitly {@link tensorflow.TensorInfo.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.TensorInfo
         * @static
         * @param {tensorflow.ITensorInfo} message TensorInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.dtype != null && message.hasOwnProperty("dtype"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dtype);
            if (message.tensorShape != null && message.hasOwnProperty("tensorShape"))
                $root.tensorflow.TensorShape.encode(message.tensorShape, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.cooSparse != null && message.hasOwnProperty("cooSparse"))
                $root.tensorflow.TensorInfo.CooSparse.encode(message.cooSparse, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TensorInfo message, length delimited. Does not implicitly {@link tensorflow.TensorInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.TensorInfo
         * @static
         * @param {tensorflow.ITensorInfo} message TensorInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TensorInfo message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.TensorInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.TensorInfo} TensorInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.TensorInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 4:
                    message.cooSparse = $root.tensorflow.TensorInfo.CooSparse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.dtype = reader.int32();
                    break;
                case 3:
                    message.tensorShape = $root.tensorflow.TensorShape.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TensorInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.TensorInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.TensorInfo} TensorInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TensorInfo message.
         * @function verify
         * @memberof tensorflow.TensorInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TensorInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.name != null && message.hasOwnProperty("name")) {
                properties.encoding = 1;
                if (!$util.isString(message.name))
                    return "name: string expected";
            }
            if (message.cooSparse != null && message.hasOwnProperty("cooSparse")) {
                if (properties.encoding === 1)
                    return "encoding: multiple values";
                properties.encoding = 1;
                {
                    var error = $root.tensorflow.TensorInfo.CooSparse.verify(message.cooSparse);
                    if (error)
                        return "cooSparse." + error;
                }
            }
            if (message.dtype != null && message.hasOwnProperty("dtype"))
                switch (message.dtype) {
                default:
                    return "dtype: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                    break;
                }
            if (message.tensorShape != null && message.hasOwnProperty("tensorShape")) {
                var error = $root.tensorflow.TensorShape.verify(message.tensorShape);
                if (error)
                    return "tensorShape." + error;
            }
            return null;
        };

        /**
         * Creates a TensorInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.TensorInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.TensorInfo} TensorInfo
         */
        TensorInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.TensorInfo)
                return object;
            var message = new $root.tensorflow.TensorInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.cooSparse != null) {
                if (typeof object.cooSparse !== "object")
                    throw TypeError(".tensorflow.TensorInfo.cooSparse: object expected");
                message.cooSparse = $root.tensorflow.TensorInfo.CooSparse.fromObject(object.cooSparse);
            }
            switch (object.dtype) {
            case "DT_INVALID":
            case 0:
                message.dtype = 0;
                break;
            case "DT_FLOAT":
            case 1:
                message.dtype = 1;
                break;
            case "DT_DOUBLE":
            case 2:
                message.dtype = 2;
                break;
            case "DT_INT32":
            case 3:
                message.dtype = 3;
                break;
            case "DT_UINT8":
            case 4:
                message.dtype = 4;
                break;
            case "DT_INT16":
            case 5:
                message.dtype = 5;
                break;
            case "DT_INT8":
            case 6:
                message.dtype = 6;
                break;
            case "DT_STRING":
            case 7:
                message.dtype = 7;
                break;
            case "DT_COMPLEX64":
            case 8:
                message.dtype = 8;
                break;
            case "DT_INT64":
            case 9:
                message.dtype = 9;
                break;
            case "DT_BOOL":
            case 10:
                message.dtype = 10;
                break;
            case "DT_QINT8":
            case 11:
                message.dtype = 11;
                break;
            case "DT_QUINT8":
            case 12:
                message.dtype = 12;
                break;
            case "DT_QINT32":
            case 13:
                message.dtype = 13;
                break;
            case "DT_BFLOAT16":
            case 14:
                message.dtype = 14;
                break;
            case "DT_FLOAT_REF":
            case 101:
                message.dtype = 101;
                break;
            case "DT_DOUBLE_REF":
            case 102:
                message.dtype = 102;
                break;
            case "DT_INT32_REF":
            case 103:
                message.dtype = 103;
                break;
            case "DT_UINT8_REF":
            case 104:
                message.dtype = 104;
                break;
            case "DT_INT16_REF":
            case 105:
                message.dtype = 105;
                break;
            case "DT_INT8_REF":
            case 106:
                message.dtype = 106;
                break;
            case "DT_STRING_REF":
            case 107:
                message.dtype = 107;
                break;
            case "DT_COMPLEX64_REF":
            case 108:
                message.dtype = 108;
                break;
            case "DT_INT64_REF":
            case 109:
                message.dtype = 109;
                break;
            case "DT_BOOL_REF":
            case 110:
                message.dtype = 110;
                break;
            case "DT_QINT8_REF":
            case 111:
                message.dtype = 111;
                break;
            case "DT_QUINT8_REF":
            case 112:
                message.dtype = 112;
                break;
            case "DT_QINT32_REF":
            case 113:
                message.dtype = 113;
                break;
            case "DT_BFLOAT16_REF":
            case 114:
                message.dtype = 114;
                break;
            }
            if (object.tensorShape != null) {
                if (typeof object.tensorShape !== "object")
                    throw TypeError(".tensorflow.TensorInfo.tensorShape: object expected");
                message.tensorShape = $root.tensorflow.TensorShape.fromObject(object.tensorShape);
            }
            return message;
        };

        /**
         * Creates a plain object from a TensorInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.TensorInfo
         * @static
         * @param {tensorflow.TensorInfo} message TensorInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TensorInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dtype = options.enums === String ? "DT_INVALID" : 0;
                object.tensorShape = null;
            }
            if (message.name != null && message.hasOwnProperty("name")) {
                object.name = message.name;
                if (options.oneofs)
                    object.encoding = "name";
            }
            if (message.dtype != null && message.hasOwnProperty("dtype"))
                object.dtype = options.enums === String ? $root.tensorflow.DataType[message.dtype] : message.dtype;
            if (message.tensorShape != null && message.hasOwnProperty("tensorShape"))
                object.tensorShape = $root.tensorflow.TensorShape.toObject(message.tensorShape, options);
            if (message.cooSparse != null && message.hasOwnProperty("cooSparse")) {
                object.cooSparse = $root.tensorflow.TensorInfo.CooSparse.toObject(message.cooSparse, options);
                if (options.oneofs)
                    object.encoding = "cooSparse";
            }
            return object;
        };

        /**
         * Converts this TensorInfo to JSON.
         * @function toJSON
         * @memberof tensorflow.TensorInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TensorInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        TensorInfo.CooSparse = (function() {

            /**
             * Properties of a CooSparse.
             * @memberof tensorflow.TensorInfo
             * @interface ICooSparse
             * @property {string|null} [valuesTensorName] CooSparse valuesTensorName
             * @property {string|null} [indicesTensorName] CooSparse indicesTensorName
             * @property {string|null} [denseShapeTensorName] CooSparse denseShapeTensorName
             */

            /**
             * Constructs a new CooSparse.
             * @memberof tensorflow.TensorInfo
             * @classdesc Represents a CooSparse.
             * @implements ICooSparse
             * @constructor
             * @param {tensorflow.TensorInfo.ICooSparse=} [properties] Properties to set
             */
            function CooSparse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CooSparse valuesTensorName.
             * @member {string} valuesTensorName
             * @memberof tensorflow.TensorInfo.CooSparse
             * @instance
             */
            CooSparse.prototype.valuesTensorName = "";

            /**
             * CooSparse indicesTensorName.
             * @member {string} indicesTensorName
             * @memberof tensorflow.TensorInfo.CooSparse
             * @instance
             */
            CooSparse.prototype.indicesTensorName = "";

            /**
             * CooSparse denseShapeTensorName.
             * @member {string} denseShapeTensorName
             * @memberof tensorflow.TensorInfo.CooSparse
             * @instance
             */
            CooSparse.prototype.denseShapeTensorName = "";

            /**
             * Creates a new CooSparse instance using the specified properties.
             * @function create
             * @memberof tensorflow.TensorInfo.CooSparse
             * @static
             * @param {tensorflow.TensorInfo.ICooSparse=} [properties] Properties to set
             * @returns {tensorflow.TensorInfo.CooSparse} CooSparse instance
             */
            CooSparse.create = function create(properties) {
                return new CooSparse(properties);
            };

            /**
             * Encodes the specified CooSparse message. Does not implicitly {@link tensorflow.TensorInfo.CooSparse.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.TensorInfo.CooSparse
             * @static
             * @param {tensorflow.TensorInfo.ICooSparse} message CooSparse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CooSparse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.valuesTensorName != null && message.hasOwnProperty("valuesTensorName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.valuesTensorName);
                if (message.indicesTensorName != null && message.hasOwnProperty("indicesTensorName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.indicesTensorName);
                if (message.denseShapeTensorName != null && message.hasOwnProperty("denseShapeTensorName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.denseShapeTensorName);
                return writer;
            };

            /**
             * Encodes the specified CooSparse message, length delimited. Does not implicitly {@link tensorflow.TensorInfo.CooSparse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.TensorInfo.CooSparse
             * @static
             * @param {tensorflow.TensorInfo.ICooSparse} message CooSparse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CooSparse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CooSparse message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.TensorInfo.CooSparse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.TensorInfo.CooSparse} CooSparse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CooSparse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.TensorInfo.CooSparse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.valuesTensorName = reader.string();
                        break;
                    case 2:
                        message.indicesTensorName = reader.string();
                        break;
                    case 3:
                        message.denseShapeTensorName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CooSparse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.TensorInfo.CooSparse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.TensorInfo.CooSparse} CooSparse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CooSparse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CooSparse message.
             * @function verify
             * @memberof tensorflow.TensorInfo.CooSparse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CooSparse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.valuesTensorName != null && message.hasOwnProperty("valuesTensorName"))
                    if (!$util.isString(message.valuesTensorName))
                        return "valuesTensorName: string expected";
                if (message.indicesTensorName != null && message.hasOwnProperty("indicesTensorName"))
                    if (!$util.isString(message.indicesTensorName))
                        return "indicesTensorName: string expected";
                if (message.denseShapeTensorName != null && message.hasOwnProperty("denseShapeTensorName"))
                    if (!$util.isString(message.denseShapeTensorName))
                        return "denseShapeTensorName: string expected";
                return null;
            };

            /**
             * Creates a CooSparse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.TensorInfo.CooSparse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.TensorInfo.CooSparse} CooSparse
             */
            CooSparse.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.TensorInfo.CooSparse)
                    return object;
                var message = new $root.tensorflow.TensorInfo.CooSparse();
                if (object.valuesTensorName != null)
                    message.valuesTensorName = String(object.valuesTensorName);
                if (object.indicesTensorName != null)
                    message.indicesTensorName = String(object.indicesTensorName);
                if (object.denseShapeTensorName != null)
                    message.denseShapeTensorName = String(object.denseShapeTensorName);
                return message;
            };

            /**
             * Creates a plain object from a CooSparse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.TensorInfo.CooSparse
             * @static
             * @param {tensorflow.TensorInfo.CooSparse} message CooSparse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CooSparse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.valuesTensorName = "";
                    object.indicesTensorName = "";
                    object.denseShapeTensorName = "";
                }
                if (message.valuesTensorName != null && message.hasOwnProperty("valuesTensorName"))
                    object.valuesTensorName = message.valuesTensorName;
                if (message.indicesTensorName != null && message.hasOwnProperty("indicesTensorName"))
                    object.indicesTensorName = message.indicesTensorName;
                if (message.denseShapeTensorName != null && message.hasOwnProperty("denseShapeTensorName"))
                    object.denseShapeTensorName = message.denseShapeTensorName;
                return object;
            };

            /**
             * Converts this CooSparse to JSON.
             * @function toJSON
             * @memberof tensorflow.TensorInfo.CooSparse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CooSparse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CooSparse;
        })();

        return TensorInfo;
    })();

    tensorflow.SignatureDef = (function() {

        /**
         * Properties of a SignatureDef.
         * @memberof tensorflow
         * @interface ISignatureDef
         * @property {Object.<string,tensorflow.ITensorInfo>|null} [inputs] SignatureDef inputs
         * @property {Object.<string,tensorflow.ITensorInfo>|null} [outputs] SignatureDef outputs
         * @property {string|null} [methodName] SignatureDef methodName
         */

        /**
         * Constructs a new SignatureDef.
         * @memberof tensorflow
         * @classdesc Represents a SignatureDef.
         * @implements ISignatureDef
         * @constructor
         * @param {tensorflow.ISignatureDef=} [properties] Properties to set
         */
        function SignatureDef(properties) {
            this.inputs = {};
            this.outputs = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignatureDef inputs.
         * @member {Object.<string,tensorflow.ITensorInfo>} inputs
         * @memberof tensorflow.SignatureDef
         * @instance
         */
        SignatureDef.prototype.inputs = $util.emptyObject;

        /**
         * SignatureDef outputs.
         * @member {Object.<string,tensorflow.ITensorInfo>} outputs
         * @memberof tensorflow.SignatureDef
         * @instance
         */
        SignatureDef.prototype.outputs = $util.emptyObject;

        /**
         * SignatureDef methodName.
         * @member {string} methodName
         * @memberof tensorflow.SignatureDef
         * @instance
         */
        SignatureDef.prototype.methodName = "";

        /**
         * Creates a new SignatureDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.SignatureDef
         * @static
         * @param {tensorflow.ISignatureDef=} [properties] Properties to set
         * @returns {tensorflow.SignatureDef} SignatureDef instance
         */
        SignatureDef.create = function create(properties) {
            return new SignatureDef(properties);
        };

        /**
         * Encodes the specified SignatureDef message. Does not implicitly {@link tensorflow.SignatureDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.SignatureDef
         * @static
         * @param {tensorflow.ISignatureDef} message SignatureDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.inputs != null && message.hasOwnProperty("inputs"))
                for (var keys = Object.keys(message.inputs), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.tensorflow.TensorInfo.encode(message.inputs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.outputs != null && message.hasOwnProperty("outputs"))
                for (var keys = Object.keys(message.outputs), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.tensorflow.TensorInfo.encode(message.outputs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.methodName != null && message.hasOwnProperty("methodName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.methodName);
            return writer;
        };

        /**
         * Encodes the specified SignatureDef message, length delimited. Does not implicitly {@link tensorflow.SignatureDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.SignatureDef
         * @static
         * @param {tensorflow.ISignatureDef} message SignatureDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignatureDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.SignatureDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.SignatureDef} SignatureDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.SignatureDef(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.inputs === $util.emptyObject)
                        message.inputs = {};
                    key = reader.string();
                    reader.pos++;
                    message.inputs[key] = $root.tensorflow.TensorInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    reader.skip().pos++;
                    if (message.outputs === $util.emptyObject)
                        message.outputs = {};
                    key = reader.string();
                    reader.pos++;
                    message.outputs[key] = $root.tensorflow.TensorInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.methodName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignatureDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.SignatureDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.SignatureDef} SignatureDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignatureDef message.
         * @function verify
         * @memberof tensorflow.SignatureDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignatureDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.inputs != null && message.hasOwnProperty("inputs")) {
                if (!$util.isObject(message.inputs))
                    return "inputs: object expected";
                var key = Object.keys(message.inputs);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.tensorflow.TensorInfo.verify(message.inputs[key[i]]);
                    if (error)
                        return "inputs." + error;
                }
            }
            if (message.outputs != null && message.hasOwnProperty("outputs")) {
                if (!$util.isObject(message.outputs))
                    return "outputs: object expected";
                var key = Object.keys(message.outputs);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.tensorflow.TensorInfo.verify(message.outputs[key[i]]);
                    if (error)
                        return "outputs." + error;
                }
            }
            if (message.methodName != null && message.hasOwnProperty("methodName"))
                if (!$util.isString(message.methodName))
                    return "methodName: string expected";
            return null;
        };

        /**
         * Creates a SignatureDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.SignatureDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.SignatureDef} SignatureDef
         */
        SignatureDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.SignatureDef)
                return object;
            var message = new $root.tensorflow.SignatureDef();
            if (object.inputs) {
                if (typeof object.inputs !== "object")
                    throw TypeError(".tensorflow.SignatureDef.inputs: object expected");
                message.inputs = {};
                for (var keys = Object.keys(object.inputs), i = 0; i < keys.length; ++i) {
                    if (typeof object.inputs[keys[i]] !== "object")
                        throw TypeError(".tensorflow.SignatureDef.inputs: object expected");
                    message.inputs[keys[i]] = $root.tensorflow.TensorInfo.fromObject(object.inputs[keys[i]]);
                }
            }
            if (object.outputs) {
                if (typeof object.outputs !== "object")
                    throw TypeError(".tensorflow.SignatureDef.outputs: object expected");
                message.outputs = {};
                for (var keys = Object.keys(object.outputs), i = 0; i < keys.length; ++i) {
                    if (typeof object.outputs[keys[i]] !== "object")
                        throw TypeError(".tensorflow.SignatureDef.outputs: object expected");
                    message.outputs[keys[i]] = $root.tensorflow.TensorInfo.fromObject(object.outputs[keys[i]]);
                }
            }
            if (object.methodName != null)
                message.methodName = String(object.methodName);
            return message;
        };

        /**
         * Creates a plain object from a SignatureDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.SignatureDef
         * @static
         * @param {tensorflow.SignatureDef} message SignatureDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignatureDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.inputs = {};
                object.outputs = {};
            }
            if (options.defaults)
                object.methodName = "";
            var keys2;
            if (message.inputs && (keys2 = Object.keys(message.inputs)).length) {
                object.inputs = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.inputs[keys2[j]] = $root.tensorflow.TensorInfo.toObject(message.inputs[keys2[j]], options);
            }
            if (message.outputs && (keys2 = Object.keys(message.outputs)).length) {
                object.outputs = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.outputs[keys2[j]] = $root.tensorflow.TensorInfo.toObject(message.outputs[keys2[j]], options);
            }
            if (message.methodName != null && message.hasOwnProperty("methodName"))
                object.methodName = message.methodName;
            return object;
        };

        /**
         * Converts this SignatureDef to JSON.
         * @function toJSON
         * @memberof tensorflow.SignatureDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignatureDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignatureDef;
    })();

    tensorflow.AssetFileDef = (function() {

        /**
         * Properties of an AssetFileDef.
         * @memberof tensorflow
         * @interface IAssetFileDef
         * @property {tensorflow.ITensorInfo|null} [tensorInfo] AssetFileDef tensorInfo
         * @property {string|null} [filename] AssetFileDef filename
         */

        /**
         * Constructs a new AssetFileDef.
         * @memberof tensorflow
         * @classdesc Represents an AssetFileDef.
         * @implements IAssetFileDef
         * @constructor
         * @param {tensorflow.IAssetFileDef=} [properties] Properties to set
         */
        function AssetFileDef(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AssetFileDef tensorInfo.
         * @member {tensorflow.ITensorInfo|null|undefined} tensorInfo
         * @memberof tensorflow.AssetFileDef
         * @instance
         */
        AssetFileDef.prototype.tensorInfo = null;

        /**
         * AssetFileDef filename.
         * @member {string} filename
         * @memberof tensorflow.AssetFileDef
         * @instance
         */
        AssetFileDef.prototype.filename = "";

        /**
         * Creates a new AssetFileDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.AssetFileDef
         * @static
         * @param {tensorflow.IAssetFileDef=} [properties] Properties to set
         * @returns {tensorflow.AssetFileDef} AssetFileDef instance
         */
        AssetFileDef.create = function create(properties) {
            return new AssetFileDef(properties);
        };

        /**
         * Encodes the specified AssetFileDef message. Does not implicitly {@link tensorflow.AssetFileDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.AssetFileDef
         * @static
         * @param {tensorflow.IAssetFileDef} message AssetFileDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetFileDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tensorInfo != null && message.hasOwnProperty("tensorInfo"))
                $root.tensorflow.TensorInfo.encode(message.tensorInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.filename != null && message.hasOwnProperty("filename"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.filename);
            return writer;
        };

        /**
         * Encodes the specified AssetFileDef message, length delimited. Does not implicitly {@link tensorflow.AssetFileDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.AssetFileDef
         * @static
         * @param {tensorflow.IAssetFileDef} message AssetFileDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetFileDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AssetFileDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.AssetFileDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.AssetFileDef} AssetFileDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetFileDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.AssetFileDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tensorInfo = $root.tensorflow.TensorInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filename = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AssetFileDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.AssetFileDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.AssetFileDef} AssetFileDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetFileDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AssetFileDef message.
         * @function verify
         * @memberof tensorflow.AssetFileDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AssetFileDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tensorInfo != null && message.hasOwnProperty("tensorInfo")) {
                var error = $root.tensorflow.TensorInfo.verify(message.tensorInfo);
                if (error)
                    return "tensorInfo." + error;
            }
            if (message.filename != null && message.hasOwnProperty("filename"))
                if (!$util.isString(message.filename))
                    return "filename: string expected";
            return null;
        };

        /**
         * Creates an AssetFileDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.AssetFileDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.AssetFileDef} AssetFileDef
         */
        AssetFileDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.AssetFileDef)
                return object;
            var message = new $root.tensorflow.AssetFileDef();
            if (object.tensorInfo != null) {
                if (typeof object.tensorInfo !== "object")
                    throw TypeError(".tensorflow.AssetFileDef.tensorInfo: object expected");
                message.tensorInfo = $root.tensorflow.TensorInfo.fromObject(object.tensorInfo);
            }
            if (object.filename != null)
                message.filename = String(object.filename);
            return message;
        };

        /**
         * Creates a plain object from an AssetFileDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.AssetFileDef
         * @static
         * @param {tensorflow.AssetFileDef} message AssetFileDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AssetFileDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tensorInfo = null;
                object.filename = "";
            }
            if (message.tensorInfo != null && message.hasOwnProperty("tensorInfo"))
                object.tensorInfo = $root.tensorflow.TensorInfo.toObject(message.tensorInfo, options);
            if (message.filename != null && message.hasOwnProperty("filename"))
                object.filename = message.filename;
            return object;
        };

        /**
         * Converts this AssetFileDef to JSON.
         * @function toJSON
         * @memberof tensorflow.AssetFileDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AssetFileDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AssetFileDef;
    })();

    tensorflow.OpDef = (function() {

        /**
         * Properties of an OpDef.
         * @memberof tensorflow
         * @interface IOpDef
         * @property {string|null} [name] OpDef name
         * @property {Array.<tensorflow.OpDef.IArgDef>|null} [inputArg] OpDef inputArg
         * @property {Array.<tensorflow.OpDef.IArgDef>|null} [outputArg] OpDef outputArg
         * @property {Array.<tensorflow.OpDef.IAttrDef>|null} [attr] OpDef attr
         * @property {tensorflow.OpDef.IOpDeprecation|null} [deprecation] OpDef deprecation
         * @property {string|null} [summary] OpDef summary
         * @property {string|null} [description] OpDef description
         * @property {boolean|null} [isCommutative] OpDef isCommutative
         * @property {boolean|null} [isAggregate] OpDef isAggregate
         * @property {boolean|null} [isStateful] OpDef isStateful
         * @property {boolean|null} [allowsUninitializedInput] OpDef allowsUninitializedInput
         */

        /**
         * Constructs a new OpDef.
         * @memberof tensorflow
         * @classdesc Represents an OpDef.
         * @implements IOpDef
         * @constructor
         * @param {tensorflow.IOpDef=} [properties] Properties to set
         */
        function OpDef(properties) {
            this.inputArg = [];
            this.outputArg = [];
            this.attr = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpDef name.
         * @member {string} name
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.name = "";

        /**
         * OpDef inputArg.
         * @member {Array.<tensorflow.OpDef.IArgDef>} inputArg
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.inputArg = $util.emptyArray;

        /**
         * OpDef outputArg.
         * @member {Array.<tensorflow.OpDef.IArgDef>} outputArg
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.outputArg = $util.emptyArray;

        /**
         * OpDef attr.
         * @member {Array.<tensorflow.OpDef.IAttrDef>} attr
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.attr = $util.emptyArray;

        /**
         * OpDef deprecation.
         * @member {tensorflow.OpDef.IOpDeprecation|null|undefined} deprecation
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.deprecation = null;

        /**
         * OpDef summary.
         * @member {string} summary
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.summary = "";

        /**
         * OpDef description.
         * @member {string} description
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.description = "";

        /**
         * OpDef isCommutative.
         * @member {boolean} isCommutative
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.isCommutative = false;

        /**
         * OpDef isAggregate.
         * @member {boolean} isAggregate
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.isAggregate = false;

        /**
         * OpDef isStateful.
         * @member {boolean} isStateful
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.isStateful = false;

        /**
         * OpDef allowsUninitializedInput.
         * @member {boolean} allowsUninitializedInput
         * @memberof tensorflow.OpDef
         * @instance
         */
        OpDef.prototype.allowsUninitializedInput = false;

        /**
         * Creates a new OpDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.OpDef
         * @static
         * @param {tensorflow.IOpDef=} [properties] Properties to set
         * @returns {tensorflow.OpDef} OpDef instance
         */
        OpDef.create = function create(properties) {
            return new OpDef(properties);
        };

        /**
         * Encodes the specified OpDef message. Does not implicitly {@link tensorflow.OpDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.OpDef
         * @static
         * @param {tensorflow.IOpDef} message OpDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.inputArg != null && message.inputArg.length)
                for (var i = 0; i < message.inputArg.length; ++i)
                    $root.tensorflow.OpDef.ArgDef.encode(message.inputArg[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.outputArg != null && message.outputArg.length)
                for (var i = 0; i < message.outputArg.length; ++i)
                    $root.tensorflow.OpDef.ArgDef.encode(message.outputArg[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.attr != null && message.attr.length)
                for (var i = 0; i < message.attr.length; ++i)
                    $root.tensorflow.OpDef.AttrDef.encode(message.attr[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.summary != null && message.hasOwnProperty("summary"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.summary);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
            if (message.deprecation != null && message.hasOwnProperty("deprecation"))
                $root.tensorflow.OpDef.OpDeprecation.encode(message.deprecation, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.isAggregate != null && message.hasOwnProperty("isAggregate"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.isAggregate);
            if (message.isStateful != null && message.hasOwnProperty("isStateful"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.isStateful);
            if (message.isCommutative != null && message.hasOwnProperty("isCommutative"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.isCommutative);
            if (message.allowsUninitializedInput != null && message.hasOwnProperty("allowsUninitializedInput"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.allowsUninitializedInput);
            return writer;
        };

        /**
         * Encodes the specified OpDef message, length delimited. Does not implicitly {@link tensorflow.OpDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.OpDef
         * @static
         * @param {tensorflow.IOpDef} message OpDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.OpDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.OpDef} OpDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.OpDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    if (!(message.inputArg && message.inputArg.length))
                        message.inputArg = [];
                    message.inputArg.push($root.tensorflow.OpDef.ArgDef.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.outputArg && message.outputArg.length))
                        message.outputArg = [];
                    message.outputArg.push($root.tensorflow.OpDef.ArgDef.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.attr && message.attr.length))
                        message.attr = [];
                    message.attr.push($root.tensorflow.OpDef.AttrDef.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.deprecation = $root.tensorflow.OpDef.OpDeprecation.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.summary = reader.string();
                    break;
                case 6:
                    message.description = reader.string();
                    break;
                case 18:
                    message.isCommutative = reader.bool();
                    break;
                case 16:
                    message.isAggregate = reader.bool();
                    break;
                case 17:
                    message.isStateful = reader.bool();
                    break;
                case 19:
                    message.allowsUninitializedInput = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.OpDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.OpDef} OpDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpDef message.
         * @function verify
         * @memberof tensorflow.OpDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.inputArg != null && message.hasOwnProperty("inputArg")) {
                if (!Array.isArray(message.inputArg))
                    return "inputArg: array expected";
                for (var i = 0; i < message.inputArg.length; ++i) {
                    var error = $root.tensorflow.OpDef.ArgDef.verify(message.inputArg[i]);
                    if (error)
                        return "inputArg." + error;
                }
            }
            if (message.outputArg != null && message.hasOwnProperty("outputArg")) {
                if (!Array.isArray(message.outputArg))
                    return "outputArg: array expected";
                for (var i = 0; i < message.outputArg.length; ++i) {
                    var error = $root.tensorflow.OpDef.ArgDef.verify(message.outputArg[i]);
                    if (error)
                        return "outputArg." + error;
                }
            }
            if (message.attr != null && message.hasOwnProperty("attr")) {
                if (!Array.isArray(message.attr))
                    return "attr: array expected";
                for (var i = 0; i < message.attr.length; ++i) {
                    var error = $root.tensorflow.OpDef.AttrDef.verify(message.attr[i]);
                    if (error)
                        return "attr." + error;
                }
            }
            if (message.deprecation != null && message.hasOwnProperty("deprecation")) {
                var error = $root.tensorflow.OpDef.OpDeprecation.verify(message.deprecation);
                if (error)
                    return "deprecation." + error;
            }
            if (message.summary != null && message.hasOwnProperty("summary"))
                if (!$util.isString(message.summary))
                    return "summary: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.isCommutative != null && message.hasOwnProperty("isCommutative"))
                if (typeof message.isCommutative !== "boolean")
                    return "isCommutative: boolean expected";
            if (message.isAggregate != null && message.hasOwnProperty("isAggregate"))
                if (typeof message.isAggregate !== "boolean")
                    return "isAggregate: boolean expected";
            if (message.isStateful != null && message.hasOwnProperty("isStateful"))
                if (typeof message.isStateful !== "boolean")
                    return "isStateful: boolean expected";
            if (message.allowsUninitializedInput != null && message.hasOwnProperty("allowsUninitializedInput"))
                if (typeof message.allowsUninitializedInput !== "boolean")
                    return "allowsUninitializedInput: boolean expected";
            return null;
        };

        /**
         * Creates an OpDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.OpDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.OpDef} OpDef
         */
        OpDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.OpDef)
                return object;
            var message = new $root.tensorflow.OpDef();
            if (object.name != null)
                message.name = String(object.name);
            if (object.inputArg) {
                if (!Array.isArray(object.inputArg))
                    throw TypeError(".tensorflow.OpDef.inputArg: array expected");
                message.inputArg = [];
                for (var i = 0; i < object.inputArg.length; ++i) {
                    if (typeof object.inputArg[i] !== "object")
                        throw TypeError(".tensorflow.OpDef.inputArg: object expected");
                    message.inputArg[i] = $root.tensorflow.OpDef.ArgDef.fromObject(object.inputArg[i]);
                }
            }
            if (object.outputArg) {
                if (!Array.isArray(object.outputArg))
                    throw TypeError(".tensorflow.OpDef.outputArg: array expected");
                message.outputArg = [];
                for (var i = 0; i < object.outputArg.length; ++i) {
                    if (typeof object.outputArg[i] !== "object")
                        throw TypeError(".tensorflow.OpDef.outputArg: object expected");
                    message.outputArg[i] = $root.tensorflow.OpDef.ArgDef.fromObject(object.outputArg[i]);
                }
            }
            if (object.attr) {
                if (!Array.isArray(object.attr))
                    throw TypeError(".tensorflow.OpDef.attr: array expected");
                message.attr = [];
                for (var i = 0; i < object.attr.length; ++i) {
                    if (typeof object.attr[i] !== "object")
                        throw TypeError(".tensorflow.OpDef.attr: object expected");
                    message.attr[i] = $root.tensorflow.OpDef.AttrDef.fromObject(object.attr[i]);
                }
            }
            if (object.deprecation != null) {
                if (typeof object.deprecation !== "object")
                    throw TypeError(".tensorflow.OpDef.deprecation: object expected");
                message.deprecation = $root.tensorflow.OpDef.OpDeprecation.fromObject(object.deprecation);
            }
            if (object.summary != null)
                message.summary = String(object.summary);
            if (object.description != null)
                message.description = String(object.description);
            if (object.isCommutative != null)
                message.isCommutative = Boolean(object.isCommutative);
            if (object.isAggregate != null)
                message.isAggregate = Boolean(object.isAggregate);
            if (object.isStateful != null)
                message.isStateful = Boolean(object.isStateful);
            if (object.allowsUninitializedInput != null)
                message.allowsUninitializedInput = Boolean(object.allowsUninitializedInput);
            return message;
        };

        /**
         * Creates a plain object from an OpDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.OpDef
         * @static
         * @param {tensorflow.OpDef} message OpDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.inputArg = [];
                object.outputArg = [];
                object.attr = [];
            }
            if (options.defaults) {
                object.name = "";
                object.summary = "";
                object.description = "";
                object.deprecation = null;
                object.isAggregate = false;
                object.isStateful = false;
                object.isCommutative = false;
                object.allowsUninitializedInput = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.inputArg && message.inputArg.length) {
                object.inputArg = [];
                for (var j = 0; j < message.inputArg.length; ++j)
                    object.inputArg[j] = $root.tensorflow.OpDef.ArgDef.toObject(message.inputArg[j], options);
            }
            if (message.outputArg && message.outputArg.length) {
                object.outputArg = [];
                for (var j = 0; j < message.outputArg.length; ++j)
                    object.outputArg[j] = $root.tensorflow.OpDef.ArgDef.toObject(message.outputArg[j], options);
            }
            if (message.attr && message.attr.length) {
                object.attr = [];
                for (var j = 0; j < message.attr.length; ++j)
                    object.attr[j] = $root.tensorflow.OpDef.AttrDef.toObject(message.attr[j], options);
            }
            if (message.summary != null && message.hasOwnProperty("summary"))
                object.summary = message.summary;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.deprecation != null && message.hasOwnProperty("deprecation"))
                object.deprecation = $root.tensorflow.OpDef.OpDeprecation.toObject(message.deprecation, options);
            if (message.isAggregate != null && message.hasOwnProperty("isAggregate"))
                object.isAggregate = message.isAggregate;
            if (message.isStateful != null && message.hasOwnProperty("isStateful"))
                object.isStateful = message.isStateful;
            if (message.isCommutative != null && message.hasOwnProperty("isCommutative"))
                object.isCommutative = message.isCommutative;
            if (message.allowsUninitializedInput != null && message.hasOwnProperty("allowsUninitializedInput"))
                object.allowsUninitializedInput = message.allowsUninitializedInput;
            return object;
        };

        /**
         * Converts this OpDef to JSON.
         * @function toJSON
         * @memberof tensorflow.OpDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        OpDef.ArgDef = (function() {

            /**
             * Properties of an ArgDef.
             * @memberof tensorflow.OpDef
             * @interface IArgDef
             * @property {string|null} [name] ArgDef name
             * @property {string|null} [description] ArgDef description
             * @property {tensorflow.DataType|null} [type] ArgDef type
             * @property {string|null} [typeAttr] ArgDef typeAttr
             * @property {string|null} [numberAttr] ArgDef numberAttr
             * @property {string|null} [typeListAttr] ArgDef typeListAttr
             * @property {boolean|null} [isRef] ArgDef isRef
             */

            /**
             * Constructs a new ArgDef.
             * @memberof tensorflow.OpDef
             * @classdesc Represents an ArgDef.
             * @implements IArgDef
             * @constructor
             * @param {tensorflow.OpDef.IArgDef=} [properties] Properties to set
             */
            function ArgDef(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ArgDef name.
             * @member {string} name
             * @memberof tensorflow.OpDef.ArgDef
             * @instance
             */
            ArgDef.prototype.name = "";

            /**
             * ArgDef description.
             * @member {string} description
             * @memberof tensorflow.OpDef.ArgDef
             * @instance
             */
            ArgDef.prototype.description = "";

            /**
             * ArgDef type.
             * @member {tensorflow.DataType} type
             * @memberof tensorflow.OpDef.ArgDef
             * @instance
             */
            ArgDef.prototype.type = 0;

            /**
             * ArgDef typeAttr.
             * @member {string} typeAttr
             * @memberof tensorflow.OpDef.ArgDef
             * @instance
             */
            ArgDef.prototype.typeAttr = "";

            /**
             * ArgDef numberAttr.
             * @member {string} numberAttr
             * @memberof tensorflow.OpDef.ArgDef
             * @instance
             */
            ArgDef.prototype.numberAttr = "";

            /**
             * ArgDef typeListAttr.
             * @member {string} typeListAttr
             * @memberof tensorflow.OpDef.ArgDef
             * @instance
             */
            ArgDef.prototype.typeListAttr = "";

            /**
             * ArgDef isRef.
             * @member {boolean} isRef
             * @memberof tensorflow.OpDef.ArgDef
             * @instance
             */
            ArgDef.prototype.isRef = false;

            /**
             * Creates a new ArgDef instance using the specified properties.
             * @function create
             * @memberof tensorflow.OpDef.ArgDef
             * @static
             * @param {tensorflow.OpDef.IArgDef=} [properties] Properties to set
             * @returns {tensorflow.OpDef.ArgDef} ArgDef instance
             */
            ArgDef.create = function create(properties) {
                return new ArgDef(properties);
            };

            /**
             * Encodes the specified ArgDef message. Does not implicitly {@link tensorflow.OpDef.ArgDef.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.OpDef.ArgDef
             * @static
             * @param {tensorflow.OpDef.IArgDef} message ArgDef message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArgDef.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.typeAttr != null && message.hasOwnProperty("typeAttr"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.typeAttr);
                if (message.numberAttr != null && message.hasOwnProperty("numberAttr"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.numberAttr);
                if (message.typeListAttr != null && message.hasOwnProperty("typeListAttr"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeListAttr);
                if (message.isRef != null && message.hasOwnProperty("isRef"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.isRef);
                return writer;
            };

            /**
             * Encodes the specified ArgDef message, length delimited. Does not implicitly {@link tensorflow.OpDef.ArgDef.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.OpDef.ArgDef
             * @static
             * @param {tensorflow.OpDef.IArgDef} message ArgDef message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArgDef.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ArgDef message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.OpDef.ArgDef
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.OpDef.ArgDef} ArgDef
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArgDef.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.OpDef.ArgDef();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.description = reader.string();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.typeAttr = reader.string();
                        break;
                    case 5:
                        message.numberAttr = reader.string();
                        break;
                    case 6:
                        message.typeListAttr = reader.string();
                        break;
                    case 16:
                        message.isRef = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ArgDef message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.OpDef.ArgDef
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.OpDef.ArgDef} ArgDef
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArgDef.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ArgDef message.
             * @function verify
             * @memberof tensorflow.OpDef.ArgDef
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ArgDef.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 105:
                    case 106:
                    case 107:
                    case 108:
                    case 109:
                    case 110:
                    case 111:
                    case 112:
                    case 113:
                    case 114:
                        break;
                    }
                if (message.typeAttr != null && message.hasOwnProperty("typeAttr"))
                    if (!$util.isString(message.typeAttr))
                        return "typeAttr: string expected";
                if (message.numberAttr != null && message.hasOwnProperty("numberAttr"))
                    if (!$util.isString(message.numberAttr))
                        return "numberAttr: string expected";
                if (message.typeListAttr != null && message.hasOwnProperty("typeListAttr"))
                    if (!$util.isString(message.typeListAttr))
                        return "typeListAttr: string expected";
                if (message.isRef != null && message.hasOwnProperty("isRef"))
                    if (typeof message.isRef !== "boolean")
                        return "isRef: boolean expected";
                return null;
            };

            /**
             * Creates an ArgDef message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.OpDef.ArgDef
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.OpDef.ArgDef} ArgDef
             */
            ArgDef.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.OpDef.ArgDef)
                    return object;
                var message = new $root.tensorflow.OpDef.ArgDef();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.description != null)
                    message.description = String(object.description);
                switch (object.type) {
                case "DT_INVALID":
                case 0:
                    message.type = 0;
                    break;
                case "DT_FLOAT":
                case 1:
                    message.type = 1;
                    break;
                case "DT_DOUBLE":
                case 2:
                    message.type = 2;
                    break;
                case "DT_INT32":
                case 3:
                    message.type = 3;
                    break;
                case "DT_UINT8":
                case 4:
                    message.type = 4;
                    break;
                case "DT_INT16":
                case 5:
                    message.type = 5;
                    break;
                case "DT_INT8":
                case 6:
                    message.type = 6;
                    break;
                case "DT_STRING":
                case 7:
                    message.type = 7;
                    break;
                case "DT_COMPLEX64":
                case 8:
                    message.type = 8;
                    break;
                case "DT_INT64":
                case 9:
                    message.type = 9;
                    break;
                case "DT_BOOL":
                case 10:
                    message.type = 10;
                    break;
                case "DT_QINT8":
                case 11:
                    message.type = 11;
                    break;
                case "DT_QUINT8":
                case 12:
                    message.type = 12;
                    break;
                case "DT_QINT32":
                case 13:
                    message.type = 13;
                    break;
                case "DT_BFLOAT16":
                case 14:
                    message.type = 14;
                    break;
                case "DT_FLOAT_REF":
                case 101:
                    message.type = 101;
                    break;
                case "DT_DOUBLE_REF":
                case 102:
                    message.type = 102;
                    break;
                case "DT_INT32_REF":
                case 103:
                    message.type = 103;
                    break;
                case "DT_UINT8_REF":
                case 104:
                    message.type = 104;
                    break;
                case "DT_INT16_REF":
                case 105:
                    message.type = 105;
                    break;
                case "DT_INT8_REF":
                case 106:
                    message.type = 106;
                    break;
                case "DT_STRING_REF":
                case 107:
                    message.type = 107;
                    break;
                case "DT_COMPLEX64_REF":
                case 108:
                    message.type = 108;
                    break;
                case "DT_INT64_REF":
                case 109:
                    message.type = 109;
                    break;
                case "DT_BOOL_REF":
                case 110:
                    message.type = 110;
                    break;
                case "DT_QINT8_REF":
                case 111:
                    message.type = 111;
                    break;
                case "DT_QUINT8_REF":
                case 112:
                    message.type = 112;
                    break;
                case "DT_QINT32_REF":
                case 113:
                    message.type = 113;
                    break;
                case "DT_BFLOAT16_REF":
                case 114:
                    message.type = 114;
                    break;
                }
                if (object.typeAttr != null)
                    message.typeAttr = String(object.typeAttr);
                if (object.numberAttr != null)
                    message.numberAttr = String(object.numberAttr);
                if (object.typeListAttr != null)
                    message.typeListAttr = String(object.typeListAttr);
                if (object.isRef != null)
                    message.isRef = Boolean(object.isRef);
                return message;
            };

            /**
             * Creates a plain object from an ArgDef message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.OpDef.ArgDef
             * @static
             * @param {tensorflow.OpDef.ArgDef} message ArgDef
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ArgDef.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.description = "";
                    object.type = options.enums === String ? "DT_INVALID" : 0;
                    object.typeAttr = "";
                    object.numberAttr = "";
                    object.typeListAttr = "";
                    object.isRef = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.tensorflow.DataType[message.type] : message.type;
                if (message.typeAttr != null && message.hasOwnProperty("typeAttr"))
                    object.typeAttr = message.typeAttr;
                if (message.numberAttr != null && message.hasOwnProperty("numberAttr"))
                    object.numberAttr = message.numberAttr;
                if (message.typeListAttr != null && message.hasOwnProperty("typeListAttr"))
                    object.typeListAttr = message.typeListAttr;
                if (message.isRef != null && message.hasOwnProperty("isRef"))
                    object.isRef = message.isRef;
                return object;
            };

            /**
             * Converts this ArgDef to JSON.
             * @function toJSON
             * @memberof tensorflow.OpDef.ArgDef
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ArgDef.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ArgDef;
        })();

        OpDef.AttrDef = (function() {

            /**
             * Properties of an AttrDef.
             * @memberof tensorflow.OpDef
             * @interface IAttrDef
             * @property {string|null} [name] AttrDef name
             * @property {string|null} [type] AttrDef type
             * @property {tensorflow.IAttrValue|null} [defaultValue] AttrDef defaultValue
             * @property {string|null} [description] AttrDef description
             * @property {boolean|null} [hasMinimum] AttrDef hasMinimum
             * @property {number|Long|null} [minimum] AttrDef minimum
             * @property {tensorflow.IAttrValue|null} [allowedValues] AttrDef allowedValues
             */

            /**
             * Constructs a new AttrDef.
             * @memberof tensorflow.OpDef
             * @classdesc Represents an AttrDef.
             * @implements IAttrDef
             * @constructor
             * @param {tensorflow.OpDef.IAttrDef=} [properties] Properties to set
             */
            function AttrDef(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AttrDef name.
             * @member {string} name
             * @memberof tensorflow.OpDef.AttrDef
             * @instance
             */
            AttrDef.prototype.name = "";

            /**
             * AttrDef type.
             * @member {string} type
             * @memberof tensorflow.OpDef.AttrDef
             * @instance
             */
            AttrDef.prototype.type = "";

            /**
             * AttrDef defaultValue.
             * @member {tensorflow.IAttrValue|null|undefined} defaultValue
             * @memberof tensorflow.OpDef.AttrDef
             * @instance
             */
            AttrDef.prototype.defaultValue = null;

            /**
             * AttrDef description.
             * @member {string} description
             * @memberof tensorflow.OpDef.AttrDef
             * @instance
             */
            AttrDef.prototype.description = "";

            /**
             * AttrDef hasMinimum.
             * @member {boolean} hasMinimum
             * @memberof tensorflow.OpDef.AttrDef
             * @instance
             */
            AttrDef.prototype.hasMinimum = false;

            /**
             * AttrDef minimum.
             * @member {number|Long} minimum
             * @memberof tensorflow.OpDef.AttrDef
             * @instance
             */
            AttrDef.prototype.minimum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AttrDef allowedValues.
             * @member {tensorflow.IAttrValue|null|undefined} allowedValues
             * @memberof tensorflow.OpDef.AttrDef
             * @instance
             */
            AttrDef.prototype.allowedValues = null;

            /**
             * Creates a new AttrDef instance using the specified properties.
             * @function create
             * @memberof tensorflow.OpDef.AttrDef
             * @static
             * @param {tensorflow.OpDef.IAttrDef=} [properties] Properties to set
             * @returns {tensorflow.OpDef.AttrDef} AttrDef instance
             */
            AttrDef.create = function create(properties) {
                return new AttrDef(properties);
            };

            /**
             * Encodes the specified AttrDef message. Does not implicitly {@link tensorflow.OpDef.AttrDef.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.OpDef.AttrDef
             * @static
             * @param {tensorflow.OpDef.IAttrDef} message AttrDef message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttrDef.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    $root.tensorflow.AttrValue.encode(message.defaultValue, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                if (message.hasMinimum != null && message.hasOwnProperty("hasMinimum"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hasMinimum);
                if (message.minimum != null && message.hasOwnProperty("minimum"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.minimum);
                if (message.allowedValues != null && message.hasOwnProperty("allowedValues"))
                    $root.tensorflow.AttrValue.encode(message.allowedValues, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AttrDef message, length delimited. Does not implicitly {@link tensorflow.OpDef.AttrDef.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.OpDef.AttrDef
             * @static
             * @param {tensorflow.OpDef.IAttrDef} message AttrDef message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttrDef.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AttrDef message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.OpDef.AttrDef
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.OpDef.AttrDef} AttrDef
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttrDef.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.OpDef.AttrDef();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.string();
                        break;
                    case 3:
                        message.defaultValue = $root.tensorflow.AttrValue.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.description = reader.string();
                        break;
                    case 5:
                        message.hasMinimum = reader.bool();
                        break;
                    case 6:
                        message.minimum = reader.int64();
                        break;
                    case 7:
                        message.allowedValues = $root.tensorflow.AttrValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AttrDef message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.OpDef.AttrDef
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.OpDef.AttrDef} AttrDef
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttrDef.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AttrDef message.
             * @function verify
             * @memberof tensorflow.OpDef.AttrDef
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AttrDef.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue")) {
                    var error = $root.tensorflow.AttrValue.verify(message.defaultValue);
                    if (error)
                        return "defaultValue." + error;
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.hasMinimum != null && message.hasOwnProperty("hasMinimum"))
                    if (typeof message.hasMinimum !== "boolean")
                        return "hasMinimum: boolean expected";
                if (message.minimum != null && message.hasOwnProperty("minimum"))
                    if (!$util.isInteger(message.minimum) && !(message.minimum && $util.isInteger(message.minimum.low) && $util.isInteger(message.minimum.high)))
                        return "minimum: integer|Long expected";
                if (message.allowedValues != null && message.hasOwnProperty("allowedValues")) {
                    var error = $root.tensorflow.AttrValue.verify(message.allowedValues);
                    if (error)
                        return "allowedValues." + error;
                }
                return null;
            };

            /**
             * Creates an AttrDef message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.OpDef.AttrDef
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.OpDef.AttrDef} AttrDef
             */
            AttrDef.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.OpDef.AttrDef)
                    return object;
                var message = new $root.tensorflow.OpDef.AttrDef();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.type != null)
                    message.type = String(object.type);
                if (object.defaultValue != null) {
                    if (typeof object.defaultValue !== "object")
                        throw TypeError(".tensorflow.OpDef.AttrDef.defaultValue: object expected");
                    message.defaultValue = $root.tensorflow.AttrValue.fromObject(object.defaultValue);
                }
                if (object.description != null)
                    message.description = String(object.description);
                if (object.hasMinimum != null)
                    message.hasMinimum = Boolean(object.hasMinimum);
                if (object.minimum != null)
                    if ($util.Long)
                        (message.minimum = $util.Long.fromValue(object.minimum)).unsigned = false;
                    else if (typeof object.minimum === "string")
                        message.minimum = parseInt(object.minimum, 10);
                    else if (typeof object.minimum === "number")
                        message.minimum = object.minimum;
                    else if (typeof object.minimum === "object")
                        message.minimum = new $util.LongBits(object.minimum.low >>> 0, object.minimum.high >>> 0).toNumber();
                if (object.allowedValues != null) {
                    if (typeof object.allowedValues !== "object")
                        throw TypeError(".tensorflow.OpDef.AttrDef.allowedValues: object expected");
                    message.allowedValues = $root.tensorflow.AttrValue.fromObject(object.allowedValues);
                }
                return message;
            };

            /**
             * Creates a plain object from an AttrDef message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.OpDef.AttrDef
             * @static
             * @param {tensorflow.OpDef.AttrDef} message AttrDef
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AttrDef.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = "";
                    object.defaultValue = null;
                    object.description = "";
                    object.hasMinimum = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.minimum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.minimum = options.longs === String ? "0" : 0;
                    object.allowedValues = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = $root.tensorflow.AttrValue.toObject(message.defaultValue, options);
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.hasMinimum != null && message.hasOwnProperty("hasMinimum"))
                    object.hasMinimum = message.hasMinimum;
                if (message.minimum != null && message.hasOwnProperty("minimum"))
                    if (typeof message.minimum === "number")
                        object.minimum = options.longs === String ? String(message.minimum) : message.minimum;
                    else
                        object.minimum = options.longs === String ? $util.Long.prototype.toString.call(message.minimum) : options.longs === Number ? new $util.LongBits(message.minimum.low >>> 0, message.minimum.high >>> 0).toNumber() : message.minimum;
                if (message.allowedValues != null && message.hasOwnProperty("allowedValues"))
                    object.allowedValues = $root.tensorflow.AttrValue.toObject(message.allowedValues, options);
                return object;
            };

            /**
             * Converts this AttrDef to JSON.
             * @function toJSON
             * @memberof tensorflow.OpDef.AttrDef
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AttrDef.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AttrDef;
        })();

        OpDef.OpDeprecation = (function() {

            /**
             * Properties of an OpDeprecation.
             * @memberof tensorflow.OpDef
             * @interface IOpDeprecation
             * @property {number|null} [version] OpDeprecation version
             * @property {string|null} [explanation] OpDeprecation explanation
             */

            /**
             * Constructs a new OpDeprecation.
             * @memberof tensorflow.OpDef
             * @classdesc Represents an OpDeprecation.
             * @implements IOpDeprecation
             * @constructor
             * @param {tensorflow.OpDef.IOpDeprecation=} [properties] Properties to set
             */
            function OpDeprecation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OpDeprecation version.
             * @member {number} version
             * @memberof tensorflow.OpDef.OpDeprecation
             * @instance
             */
            OpDeprecation.prototype.version = 0;

            /**
             * OpDeprecation explanation.
             * @member {string} explanation
             * @memberof tensorflow.OpDef.OpDeprecation
             * @instance
             */
            OpDeprecation.prototype.explanation = "";

            /**
             * Creates a new OpDeprecation instance using the specified properties.
             * @function create
             * @memberof tensorflow.OpDef.OpDeprecation
             * @static
             * @param {tensorflow.OpDef.IOpDeprecation=} [properties] Properties to set
             * @returns {tensorflow.OpDef.OpDeprecation} OpDeprecation instance
             */
            OpDeprecation.create = function create(properties) {
                return new OpDeprecation(properties);
            };

            /**
             * Encodes the specified OpDeprecation message. Does not implicitly {@link tensorflow.OpDef.OpDeprecation.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.OpDef.OpDeprecation
             * @static
             * @param {tensorflow.OpDef.IOpDeprecation} message OpDeprecation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpDeprecation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
                if (message.explanation != null && message.hasOwnProperty("explanation"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.explanation);
                return writer;
            };

            /**
             * Encodes the specified OpDeprecation message, length delimited. Does not implicitly {@link tensorflow.OpDef.OpDeprecation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.OpDef.OpDeprecation
             * @static
             * @param {tensorflow.OpDef.IOpDeprecation} message OpDeprecation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpDeprecation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OpDeprecation message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.OpDef.OpDeprecation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.OpDef.OpDeprecation} OpDeprecation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpDeprecation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.OpDef.OpDeprecation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.int32();
                        break;
                    case 2:
                        message.explanation = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OpDeprecation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.OpDef.OpDeprecation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.OpDef.OpDeprecation} OpDeprecation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpDeprecation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OpDeprecation message.
             * @function verify
             * @memberof tensorflow.OpDef.OpDeprecation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OpDeprecation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.explanation != null && message.hasOwnProperty("explanation"))
                    if (!$util.isString(message.explanation))
                        return "explanation: string expected";
                return null;
            };

            /**
             * Creates an OpDeprecation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.OpDef.OpDeprecation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.OpDef.OpDeprecation} OpDeprecation
             */
            OpDeprecation.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.OpDef.OpDeprecation)
                    return object;
                var message = new $root.tensorflow.OpDef.OpDeprecation();
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.explanation != null)
                    message.explanation = String(object.explanation);
                return message;
            };

            /**
             * Creates a plain object from an OpDeprecation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.OpDef.OpDeprecation
             * @static
             * @param {tensorflow.OpDef.OpDeprecation} message OpDeprecation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OpDeprecation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.version = 0;
                    object.explanation = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.explanation != null && message.hasOwnProperty("explanation"))
                    object.explanation = message.explanation;
                return object;
            };

            /**
             * Converts this OpDeprecation to JSON.
             * @function toJSON
             * @memberof tensorflow.OpDef.OpDeprecation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OpDeprecation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OpDeprecation;
        })();

        return OpDef;
    })();

    tensorflow.OpList = (function() {

        /**
         * Properties of an OpList.
         * @memberof tensorflow
         * @interface IOpList
         * @property {Array.<tensorflow.IOpDef>|null} [op] OpList op
         */

        /**
         * Constructs a new OpList.
         * @memberof tensorflow
         * @classdesc Represents an OpList.
         * @implements IOpList
         * @constructor
         * @param {tensorflow.IOpList=} [properties] Properties to set
         */
        function OpList(properties) {
            this.op = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpList op.
         * @member {Array.<tensorflow.IOpDef>} op
         * @memberof tensorflow.OpList
         * @instance
         */
        OpList.prototype.op = $util.emptyArray;

        /**
         * Creates a new OpList instance using the specified properties.
         * @function create
         * @memberof tensorflow.OpList
         * @static
         * @param {tensorflow.IOpList=} [properties] Properties to set
         * @returns {tensorflow.OpList} OpList instance
         */
        OpList.create = function create(properties) {
            return new OpList(properties);
        };

        /**
         * Encodes the specified OpList message. Does not implicitly {@link tensorflow.OpList.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.OpList
         * @static
         * @param {tensorflow.IOpList} message OpList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.op != null && message.op.length)
                for (var i = 0; i < message.op.length; ++i)
                    $root.tensorflow.OpDef.encode(message.op[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OpList message, length delimited. Does not implicitly {@link tensorflow.OpList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.OpList
         * @static
         * @param {tensorflow.IOpList} message OpList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpList message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.OpList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.OpList} OpList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.OpList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.op && message.op.length))
                        message.op = [];
                    message.op.push($root.tensorflow.OpDef.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.OpList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.OpList} OpList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpList message.
         * @function verify
         * @memberof tensorflow.OpList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.op != null && message.hasOwnProperty("op")) {
                if (!Array.isArray(message.op))
                    return "op: array expected";
                for (var i = 0; i < message.op.length; ++i) {
                    var error = $root.tensorflow.OpDef.verify(message.op[i]);
                    if (error)
                        return "op." + error;
                }
            }
            return null;
        };

        /**
         * Creates an OpList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.OpList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.OpList} OpList
         */
        OpList.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.OpList)
                return object;
            var message = new $root.tensorflow.OpList();
            if (object.op) {
                if (!Array.isArray(object.op))
                    throw TypeError(".tensorflow.OpList.op: array expected");
                message.op = [];
                for (var i = 0; i < object.op.length; ++i) {
                    if (typeof object.op[i] !== "object")
                        throw TypeError(".tensorflow.OpList.op: object expected");
                    message.op[i] = $root.tensorflow.OpDef.fromObject(object.op[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an OpList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.OpList
         * @static
         * @param {tensorflow.OpList} message OpList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.op = [];
            if (message.op && message.op.length) {
                object.op = [];
                for (var j = 0; j < message.op.length; ++j)
                    object.op[j] = $root.tensorflow.OpDef.toObject(message.op[j], options);
            }
            return object;
        };

        /**
         * Converts this OpList to JSON.
         * @function toJSON
         * @memberof tensorflow.OpList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OpList;
    })();

    tensorflow.MetaGraphDef = (function() {

        /**
         * Properties of a MetaGraphDef.
         * @memberof tensorflow
         * @interface IMetaGraphDef
         * @property {tensorflow.MetaGraphDef.IMetaInfoDef|null} [metaInfoDef] MetaGraphDef metaInfoDef
         * @property {tensorflow.IGraphDef|null} [graphDef] MetaGraphDef graphDef
         * @property {tensorflow.ISaverDef|null} [saverDef] MetaGraphDef saverDef
         * @property {Object.<string,tensorflow.ICollectionDef>|null} [collectionDef] MetaGraphDef collectionDef
         * @property {Object.<string,tensorflow.ISignatureDef>|null} [signatureDef] MetaGraphDef signatureDef
         * @property {Array.<tensorflow.IAssetFileDef>|null} [assetFileDef] MetaGraphDef assetFileDef
         */

        /**
         * Constructs a new MetaGraphDef.
         * @memberof tensorflow
         * @classdesc Represents a MetaGraphDef.
         * @implements IMetaGraphDef
         * @constructor
         * @param {tensorflow.IMetaGraphDef=} [properties] Properties to set
         */
        function MetaGraphDef(properties) {
            this.collectionDef = {};
            this.signatureDef = {};
            this.assetFileDef = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MetaGraphDef metaInfoDef.
         * @member {tensorflow.MetaGraphDef.IMetaInfoDef|null|undefined} metaInfoDef
         * @memberof tensorflow.MetaGraphDef
         * @instance
         */
        MetaGraphDef.prototype.metaInfoDef = null;

        /**
         * MetaGraphDef graphDef.
         * @member {tensorflow.IGraphDef|null|undefined} graphDef
         * @memberof tensorflow.MetaGraphDef
         * @instance
         */
        MetaGraphDef.prototype.graphDef = null;

        /**
         * MetaGraphDef saverDef.
         * @member {tensorflow.ISaverDef|null|undefined} saverDef
         * @memberof tensorflow.MetaGraphDef
         * @instance
         */
        MetaGraphDef.prototype.saverDef = null;

        /**
         * MetaGraphDef collectionDef.
         * @member {Object.<string,tensorflow.ICollectionDef>} collectionDef
         * @memberof tensorflow.MetaGraphDef
         * @instance
         */
        MetaGraphDef.prototype.collectionDef = $util.emptyObject;

        /**
         * MetaGraphDef signatureDef.
         * @member {Object.<string,tensorflow.ISignatureDef>} signatureDef
         * @memberof tensorflow.MetaGraphDef
         * @instance
         */
        MetaGraphDef.prototype.signatureDef = $util.emptyObject;

        /**
         * MetaGraphDef assetFileDef.
         * @member {Array.<tensorflow.IAssetFileDef>} assetFileDef
         * @memberof tensorflow.MetaGraphDef
         * @instance
         */
        MetaGraphDef.prototype.assetFileDef = $util.emptyArray;

        /**
         * Creates a new MetaGraphDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.MetaGraphDef
         * @static
         * @param {tensorflow.IMetaGraphDef=} [properties] Properties to set
         * @returns {tensorflow.MetaGraphDef} MetaGraphDef instance
         */
        MetaGraphDef.create = function create(properties) {
            return new MetaGraphDef(properties);
        };

        /**
         * Encodes the specified MetaGraphDef message. Does not implicitly {@link tensorflow.MetaGraphDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.MetaGraphDef
         * @static
         * @param {tensorflow.IMetaGraphDef} message MetaGraphDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MetaGraphDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metaInfoDef != null && message.hasOwnProperty("metaInfoDef"))
                $root.tensorflow.MetaGraphDef.MetaInfoDef.encode(message.metaInfoDef, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.graphDef != null && message.hasOwnProperty("graphDef"))
                $root.tensorflow.GraphDef.encode(message.graphDef, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.saverDef != null && message.hasOwnProperty("saverDef"))
                $root.tensorflow.SaverDef.encode(message.saverDef, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.collectionDef != null && message.hasOwnProperty("collectionDef"))
                for (var keys = Object.keys(message.collectionDef), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.tensorflow.CollectionDef.encode(message.collectionDef[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.signatureDef != null && message.hasOwnProperty("signatureDef"))
                for (var keys = Object.keys(message.signatureDef), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.tensorflow.SignatureDef.encode(message.signatureDef[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.assetFileDef != null && message.assetFileDef.length)
                for (var i = 0; i < message.assetFileDef.length; ++i)
                    $root.tensorflow.AssetFileDef.encode(message.assetFileDef[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MetaGraphDef message, length delimited. Does not implicitly {@link tensorflow.MetaGraphDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.MetaGraphDef
         * @static
         * @param {tensorflow.IMetaGraphDef} message MetaGraphDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MetaGraphDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MetaGraphDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.MetaGraphDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.MetaGraphDef} MetaGraphDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MetaGraphDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.MetaGraphDef(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metaInfoDef = $root.tensorflow.MetaGraphDef.MetaInfoDef.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.graphDef = $root.tensorflow.GraphDef.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.saverDef = $root.tensorflow.SaverDef.decode(reader, reader.uint32());
                    break;
                case 4:
                    reader.skip().pos++;
                    if (message.collectionDef === $util.emptyObject)
                        message.collectionDef = {};
                    key = reader.string();
                    reader.pos++;
                    message.collectionDef[key] = $root.tensorflow.CollectionDef.decode(reader, reader.uint32());
                    break;
                case 5:
                    reader.skip().pos++;
                    if (message.signatureDef === $util.emptyObject)
                        message.signatureDef = {};
                    key = reader.string();
                    reader.pos++;
                    message.signatureDef[key] = $root.tensorflow.SignatureDef.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.assetFileDef && message.assetFileDef.length))
                        message.assetFileDef = [];
                    message.assetFileDef.push($root.tensorflow.AssetFileDef.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MetaGraphDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.MetaGraphDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.MetaGraphDef} MetaGraphDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MetaGraphDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MetaGraphDef message.
         * @function verify
         * @memberof tensorflow.MetaGraphDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MetaGraphDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metaInfoDef != null && message.hasOwnProperty("metaInfoDef")) {
                var error = $root.tensorflow.MetaGraphDef.MetaInfoDef.verify(message.metaInfoDef);
                if (error)
                    return "metaInfoDef." + error;
            }
            if (message.graphDef != null && message.hasOwnProperty("graphDef")) {
                var error = $root.tensorflow.GraphDef.verify(message.graphDef);
                if (error)
                    return "graphDef." + error;
            }
            if (message.saverDef != null && message.hasOwnProperty("saverDef")) {
                var error = $root.tensorflow.SaverDef.verify(message.saverDef);
                if (error)
                    return "saverDef." + error;
            }
            if (message.collectionDef != null && message.hasOwnProperty("collectionDef")) {
                if (!$util.isObject(message.collectionDef))
                    return "collectionDef: object expected";
                var key = Object.keys(message.collectionDef);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.tensorflow.CollectionDef.verify(message.collectionDef[key[i]]);
                    if (error)
                        return "collectionDef." + error;
                }
            }
            if (message.signatureDef != null && message.hasOwnProperty("signatureDef")) {
                if (!$util.isObject(message.signatureDef))
                    return "signatureDef: object expected";
                var key = Object.keys(message.signatureDef);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.tensorflow.SignatureDef.verify(message.signatureDef[key[i]]);
                    if (error)
                        return "signatureDef." + error;
                }
            }
            if (message.assetFileDef != null && message.hasOwnProperty("assetFileDef")) {
                if (!Array.isArray(message.assetFileDef))
                    return "assetFileDef: array expected";
                for (var i = 0; i < message.assetFileDef.length; ++i) {
                    var error = $root.tensorflow.AssetFileDef.verify(message.assetFileDef[i]);
                    if (error)
                        return "assetFileDef." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MetaGraphDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.MetaGraphDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.MetaGraphDef} MetaGraphDef
         */
        MetaGraphDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.MetaGraphDef)
                return object;
            var message = new $root.tensorflow.MetaGraphDef();
            if (object.metaInfoDef != null) {
                if (typeof object.metaInfoDef !== "object")
                    throw TypeError(".tensorflow.MetaGraphDef.metaInfoDef: object expected");
                message.metaInfoDef = $root.tensorflow.MetaGraphDef.MetaInfoDef.fromObject(object.metaInfoDef);
            }
            if (object.graphDef != null) {
                if (typeof object.graphDef !== "object")
                    throw TypeError(".tensorflow.MetaGraphDef.graphDef: object expected");
                message.graphDef = $root.tensorflow.GraphDef.fromObject(object.graphDef);
            }
            if (object.saverDef != null) {
                if (typeof object.saverDef !== "object")
                    throw TypeError(".tensorflow.MetaGraphDef.saverDef: object expected");
                message.saverDef = $root.tensorflow.SaverDef.fromObject(object.saverDef);
            }
            if (object.collectionDef) {
                if (typeof object.collectionDef !== "object")
                    throw TypeError(".tensorflow.MetaGraphDef.collectionDef: object expected");
                message.collectionDef = {};
                for (var keys = Object.keys(object.collectionDef), i = 0; i < keys.length; ++i) {
                    if (typeof object.collectionDef[keys[i]] !== "object")
                        throw TypeError(".tensorflow.MetaGraphDef.collectionDef: object expected");
                    message.collectionDef[keys[i]] = $root.tensorflow.CollectionDef.fromObject(object.collectionDef[keys[i]]);
                }
            }
            if (object.signatureDef) {
                if (typeof object.signatureDef !== "object")
                    throw TypeError(".tensorflow.MetaGraphDef.signatureDef: object expected");
                message.signatureDef = {};
                for (var keys = Object.keys(object.signatureDef), i = 0; i < keys.length; ++i) {
                    if (typeof object.signatureDef[keys[i]] !== "object")
                        throw TypeError(".tensorflow.MetaGraphDef.signatureDef: object expected");
                    message.signatureDef[keys[i]] = $root.tensorflow.SignatureDef.fromObject(object.signatureDef[keys[i]]);
                }
            }
            if (object.assetFileDef) {
                if (!Array.isArray(object.assetFileDef))
                    throw TypeError(".tensorflow.MetaGraphDef.assetFileDef: array expected");
                message.assetFileDef = [];
                for (var i = 0; i < object.assetFileDef.length; ++i) {
                    if (typeof object.assetFileDef[i] !== "object")
                        throw TypeError(".tensorflow.MetaGraphDef.assetFileDef: object expected");
                    message.assetFileDef[i] = $root.tensorflow.AssetFileDef.fromObject(object.assetFileDef[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MetaGraphDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.MetaGraphDef
         * @static
         * @param {tensorflow.MetaGraphDef} message MetaGraphDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MetaGraphDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.assetFileDef = [];
            if (options.objects || options.defaults) {
                object.collectionDef = {};
                object.signatureDef = {};
            }
            if (options.defaults) {
                object.metaInfoDef = null;
                object.graphDef = null;
                object.saverDef = null;
            }
            if (message.metaInfoDef != null && message.hasOwnProperty("metaInfoDef"))
                object.metaInfoDef = $root.tensorflow.MetaGraphDef.MetaInfoDef.toObject(message.metaInfoDef, options);
            if (message.graphDef != null && message.hasOwnProperty("graphDef"))
                object.graphDef = $root.tensorflow.GraphDef.toObject(message.graphDef, options);
            if (message.saverDef != null && message.hasOwnProperty("saverDef"))
                object.saverDef = $root.tensorflow.SaverDef.toObject(message.saverDef, options);
            var keys2;
            if (message.collectionDef && (keys2 = Object.keys(message.collectionDef)).length) {
                object.collectionDef = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.collectionDef[keys2[j]] = $root.tensorflow.CollectionDef.toObject(message.collectionDef[keys2[j]], options);
            }
            if (message.signatureDef && (keys2 = Object.keys(message.signatureDef)).length) {
                object.signatureDef = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.signatureDef[keys2[j]] = $root.tensorflow.SignatureDef.toObject(message.signatureDef[keys2[j]], options);
            }
            if (message.assetFileDef && message.assetFileDef.length) {
                object.assetFileDef = [];
                for (var j = 0; j < message.assetFileDef.length; ++j)
                    object.assetFileDef[j] = $root.tensorflow.AssetFileDef.toObject(message.assetFileDef[j], options);
            }
            return object;
        };

        /**
         * Converts this MetaGraphDef to JSON.
         * @function toJSON
         * @memberof tensorflow.MetaGraphDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MetaGraphDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        MetaGraphDef.MetaInfoDef = (function() {

            /**
             * Properties of a MetaInfoDef.
             * @memberof tensorflow.MetaGraphDef
             * @interface IMetaInfoDef
             * @property {string|null} [metaGraphVersion] MetaInfoDef metaGraphVersion
             * @property {tensorflow.IOpList|null} [strippedOpList] MetaInfoDef strippedOpList
             * @property {tensorflow.IAny|null} [anyInfo] MetaInfoDef anyInfo
             * @property {Array.<string>|null} [tags] MetaInfoDef tags
             * @property {string|null} [tensorflowVersion] MetaInfoDef tensorflowVersion
             * @property {string|null} [tensorflowGitVersion] MetaInfoDef tensorflowGitVersion
             */

            /**
             * Constructs a new MetaInfoDef.
             * @memberof tensorflow.MetaGraphDef
             * @classdesc Represents a MetaInfoDef.
             * @implements IMetaInfoDef
             * @constructor
             * @param {tensorflow.MetaGraphDef.IMetaInfoDef=} [properties] Properties to set
             */
            function MetaInfoDef(properties) {
                this.tags = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MetaInfoDef metaGraphVersion.
             * @member {string} metaGraphVersion
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @instance
             */
            MetaInfoDef.prototype.metaGraphVersion = "";

            /**
             * MetaInfoDef strippedOpList.
             * @member {tensorflow.IOpList|null|undefined} strippedOpList
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @instance
             */
            MetaInfoDef.prototype.strippedOpList = null;

            /**
             * MetaInfoDef anyInfo.
             * @member {tensorflow.IAny|null|undefined} anyInfo
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @instance
             */
            MetaInfoDef.prototype.anyInfo = null;

            /**
             * MetaInfoDef tags.
             * @member {Array.<string>} tags
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @instance
             */
            MetaInfoDef.prototype.tags = $util.emptyArray;

            /**
             * MetaInfoDef tensorflowVersion.
             * @member {string} tensorflowVersion
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @instance
             */
            MetaInfoDef.prototype.tensorflowVersion = "";

            /**
             * MetaInfoDef tensorflowGitVersion.
             * @member {string} tensorflowGitVersion
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @instance
             */
            MetaInfoDef.prototype.tensorflowGitVersion = "";

            /**
             * Creates a new MetaInfoDef instance using the specified properties.
             * @function create
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @static
             * @param {tensorflow.MetaGraphDef.IMetaInfoDef=} [properties] Properties to set
             * @returns {tensorflow.MetaGraphDef.MetaInfoDef} MetaInfoDef instance
             */
            MetaInfoDef.create = function create(properties) {
                return new MetaInfoDef(properties);
            };

            /**
             * Encodes the specified MetaInfoDef message. Does not implicitly {@link tensorflow.MetaGraphDef.MetaInfoDef.verify|verify} messages.
             * @function encode
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @static
             * @param {tensorflow.MetaGraphDef.IMetaInfoDef} message MetaInfoDef message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetaInfoDef.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metaGraphVersion != null && message.hasOwnProperty("metaGraphVersion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.metaGraphVersion);
                if (message.strippedOpList != null && message.hasOwnProperty("strippedOpList"))
                    $root.tensorflow.OpList.encode(message.strippedOpList, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.anyInfo != null && message.hasOwnProperty("anyInfo"))
                    $root.tensorflow.Any.encode(message.anyInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.tags != null && message.tags.length)
                    for (var i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                if (message.tensorflowVersion != null && message.hasOwnProperty("tensorflowVersion"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.tensorflowVersion);
                if (message.tensorflowGitVersion != null && message.hasOwnProperty("tensorflowGitVersion"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.tensorflowGitVersion);
                return writer;
            };

            /**
             * Encodes the specified MetaInfoDef message, length delimited. Does not implicitly {@link tensorflow.MetaGraphDef.MetaInfoDef.verify|verify} messages.
             * @function encodeDelimited
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @static
             * @param {tensorflow.MetaGraphDef.IMetaInfoDef} message MetaInfoDef message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetaInfoDef.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MetaInfoDef message from the specified reader or buffer.
             * @function decode
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {tensorflow.MetaGraphDef.MetaInfoDef} MetaInfoDef
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetaInfoDef.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.MetaGraphDef.MetaInfoDef();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.metaGraphVersion = reader.string();
                        break;
                    case 2:
                        message.strippedOpList = $root.tensorflow.OpList.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.anyInfo = $root.tensorflow.Any.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    case 5:
                        message.tensorflowVersion = reader.string();
                        break;
                    case 6:
                        message.tensorflowGitVersion = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MetaInfoDef message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {tensorflow.MetaGraphDef.MetaInfoDef} MetaInfoDef
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetaInfoDef.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MetaInfoDef message.
             * @function verify
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MetaInfoDef.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metaGraphVersion != null && message.hasOwnProperty("metaGraphVersion"))
                    if (!$util.isString(message.metaGraphVersion))
                        return "metaGraphVersion: string expected";
                if (message.strippedOpList != null && message.hasOwnProperty("strippedOpList")) {
                    var error = $root.tensorflow.OpList.verify(message.strippedOpList);
                    if (error)
                        return "strippedOpList." + error;
                }
                if (message.anyInfo != null && message.hasOwnProperty("anyInfo")) {
                    var error = $root.tensorflow.Any.verify(message.anyInfo);
                    if (error)
                        return "anyInfo." + error;
                }
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (var i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.tensorflowVersion != null && message.hasOwnProperty("tensorflowVersion"))
                    if (!$util.isString(message.tensorflowVersion))
                        return "tensorflowVersion: string expected";
                if (message.tensorflowGitVersion != null && message.hasOwnProperty("tensorflowGitVersion"))
                    if (!$util.isString(message.tensorflowGitVersion))
                        return "tensorflowGitVersion: string expected";
                return null;
            };

            /**
             * Creates a MetaInfoDef message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {tensorflow.MetaGraphDef.MetaInfoDef} MetaInfoDef
             */
            MetaInfoDef.fromObject = function fromObject(object) {
                if (object instanceof $root.tensorflow.MetaGraphDef.MetaInfoDef)
                    return object;
                var message = new $root.tensorflow.MetaGraphDef.MetaInfoDef();
                if (object.metaGraphVersion != null)
                    message.metaGraphVersion = String(object.metaGraphVersion);
                if (object.strippedOpList != null) {
                    if (typeof object.strippedOpList !== "object")
                        throw TypeError(".tensorflow.MetaGraphDef.MetaInfoDef.strippedOpList: object expected");
                    message.strippedOpList = $root.tensorflow.OpList.fromObject(object.strippedOpList);
                }
                if (object.anyInfo != null) {
                    if (typeof object.anyInfo !== "object")
                        throw TypeError(".tensorflow.MetaGraphDef.MetaInfoDef.anyInfo: object expected");
                    message.anyInfo = $root.tensorflow.Any.fromObject(object.anyInfo);
                }
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".tensorflow.MetaGraphDef.MetaInfoDef.tags: array expected");
                    message.tags = [];
                    for (var i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.tensorflowVersion != null)
                    message.tensorflowVersion = String(object.tensorflowVersion);
                if (object.tensorflowGitVersion != null)
                    message.tensorflowGitVersion = String(object.tensorflowGitVersion);
                return message;
            };

            /**
             * Creates a plain object from a MetaInfoDef message. Also converts values to other types if specified.
             * @function toObject
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @static
             * @param {tensorflow.MetaGraphDef.MetaInfoDef} message MetaInfoDef
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MetaInfoDef.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tags = [];
                if (options.defaults) {
                    object.metaGraphVersion = "";
                    object.strippedOpList = null;
                    object.anyInfo = null;
                    object.tensorflowVersion = "";
                    object.tensorflowGitVersion = "";
                }
                if (message.metaGraphVersion != null && message.hasOwnProperty("metaGraphVersion"))
                    object.metaGraphVersion = message.metaGraphVersion;
                if (message.strippedOpList != null && message.hasOwnProperty("strippedOpList"))
                    object.strippedOpList = $root.tensorflow.OpList.toObject(message.strippedOpList, options);
                if (message.anyInfo != null && message.hasOwnProperty("anyInfo"))
                    object.anyInfo = $root.tensorflow.Any.toObject(message.anyInfo, options);
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (var j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.tensorflowVersion != null && message.hasOwnProperty("tensorflowVersion"))
                    object.tensorflowVersion = message.tensorflowVersion;
                if (message.tensorflowGitVersion != null && message.hasOwnProperty("tensorflowGitVersion"))
                    object.tensorflowGitVersion = message.tensorflowGitVersion;
                return object;
            };

            /**
             * Converts this MetaInfoDef to JSON.
             * @function toJSON
             * @memberof tensorflow.MetaGraphDef.MetaInfoDef
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MetaInfoDef.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MetaInfoDef;
        })();

        return MetaGraphDef;
    })();

    tensorflow.SavedModel = (function() {

        /**
         * Properties of a SavedModel.
         * @memberof tensorflow
         * @interface ISavedModel
         * @property {number|Long|null} [savedModelSchemaVersion] SavedModel savedModelSchemaVersion
         * @property {Array.<tensorflow.IMetaGraphDef>|null} [metaGraphs] SavedModel metaGraphs
         */

        /**
         * Constructs a new SavedModel.
         * @memberof tensorflow
         * @classdesc Represents a SavedModel.
         * @implements ISavedModel
         * @constructor
         * @param {tensorflow.ISavedModel=} [properties] Properties to set
         */
        function SavedModel(properties) {
            this.metaGraphs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SavedModel savedModelSchemaVersion.
         * @member {number|Long} savedModelSchemaVersion
         * @memberof tensorflow.SavedModel
         * @instance
         */
        SavedModel.prototype.savedModelSchemaVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SavedModel metaGraphs.
         * @member {Array.<tensorflow.IMetaGraphDef>} metaGraphs
         * @memberof tensorflow.SavedModel
         * @instance
         */
        SavedModel.prototype.metaGraphs = $util.emptyArray;

        /**
         * Creates a new SavedModel instance using the specified properties.
         * @function create
         * @memberof tensorflow.SavedModel
         * @static
         * @param {tensorflow.ISavedModel=} [properties] Properties to set
         * @returns {tensorflow.SavedModel} SavedModel instance
         */
        SavedModel.create = function create(properties) {
            return new SavedModel(properties);
        };

        /**
         * Encodes the specified SavedModel message. Does not implicitly {@link tensorflow.SavedModel.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.SavedModel
         * @static
         * @param {tensorflow.ISavedModel} message SavedModel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SavedModel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.savedModelSchemaVersion != null && message.hasOwnProperty("savedModelSchemaVersion"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.savedModelSchemaVersion);
            if (message.metaGraphs != null && message.metaGraphs.length)
                for (var i = 0; i < message.metaGraphs.length; ++i)
                    $root.tensorflow.MetaGraphDef.encode(message.metaGraphs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SavedModel message, length delimited. Does not implicitly {@link tensorflow.SavedModel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.SavedModel
         * @static
         * @param {tensorflow.ISavedModel} message SavedModel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SavedModel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SavedModel message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.SavedModel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.SavedModel} SavedModel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SavedModel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.SavedModel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.savedModelSchemaVersion = reader.int64();
                    break;
                case 2:
                    if (!(message.metaGraphs && message.metaGraphs.length))
                        message.metaGraphs = [];
                    message.metaGraphs.push($root.tensorflow.MetaGraphDef.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SavedModel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.SavedModel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.SavedModel} SavedModel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SavedModel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SavedModel message.
         * @function verify
         * @memberof tensorflow.SavedModel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SavedModel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.savedModelSchemaVersion != null && message.hasOwnProperty("savedModelSchemaVersion"))
                if (!$util.isInteger(message.savedModelSchemaVersion) && !(message.savedModelSchemaVersion && $util.isInteger(message.savedModelSchemaVersion.low) && $util.isInteger(message.savedModelSchemaVersion.high)))
                    return "savedModelSchemaVersion: integer|Long expected";
            if (message.metaGraphs != null && message.hasOwnProperty("metaGraphs")) {
                if (!Array.isArray(message.metaGraphs))
                    return "metaGraphs: array expected";
                for (var i = 0; i < message.metaGraphs.length; ++i) {
                    var error = $root.tensorflow.MetaGraphDef.verify(message.metaGraphs[i]);
                    if (error)
                        return "metaGraphs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SavedModel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.SavedModel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.SavedModel} SavedModel
         */
        SavedModel.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.SavedModel)
                return object;
            var message = new $root.tensorflow.SavedModel();
            if (object.savedModelSchemaVersion != null)
                if ($util.Long)
                    (message.savedModelSchemaVersion = $util.Long.fromValue(object.savedModelSchemaVersion)).unsigned = false;
                else if (typeof object.savedModelSchemaVersion === "string")
                    message.savedModelSchemaVersion = parseInt(object.savedModelSchemaVersion, 10);
                else if (typeof object.savedModelSchemaVersion === "number")
                    message.savedModelSchemaVersion = object.savedModelSchemaVersion;
                else if (typeof object.savedModelSchemaVersion === "object")
                    message.savedModelSchemaVersion = new $util.LongBits(object.savedModelSchemaVersion.low >>> 0, object.savedModelSchemaVersion.high >>> 0).toNumber();
            if (object.metaGraphs) {
                if (!Array.isArray(object.metaGraphs))
                    throw TypeError(".tensorflow.SavedModel.metaGraphs: array expected");
                message.metaGraphs = [];
                for (var i = 0; i < object.metaGraphs.length; ++i) {
                    if (typeof object.metaGraphs[i] !== "object")
                        throw TypeError(".tensorflow.SavedModel.metaGraphs: object expected");
                    message.metaGraphs[i] = $root.tensorflow.MetaGraphDef.fromObject(object.metaGraphs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SavedModel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.SavedModel
         * @static
         * @param {tensorflow.SavedModel} message SavedModel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SavedModel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.metaGraphs = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.savedModelSchemaVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.savedModelSchemaVersion = options.longs === String ? "0" : 0;
            if (message.savedModelSchemaVersion != null && message.hasOwnProperty("savedModelSchemaVersion"))
                if (typeof message.savedModelSchemaVersion === "number")
                    object.savedModelSchemaVersion = options.longs === String ? String(message.savedModelSchemaVersion) : message.savedModelSchemaVersion;
                else
                    object.savedModelSchemaVersion = options.longs === String ? $util.Long.prototype.toString.call(message.savedModelSchemaVersion) : options.longs === Number ? new $util.LongBits(message.savedModelSchemaVersion.low >>> 0, message.savedModelSchemaVersion.high >>> 0).toNumber() : message.savedModelSchemaVersion;
            if (message.metaGraphs && message.metaGraphs.length) {
                object.metaGraphs = [];
                for (var j = 0; j < message.metaGraphs.length; ++j)
                    object.metaGraphs[j] = $root.tensorflow.MetaGraphDef.toObject(message.metaGraphs[j], options);
            }
            return object;
        };

        /**
         * Converts this SavedModel to JSON.
         * @function toJSON
         * @memberof tensorflow.SavedModel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SavedModel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SavedModel;
    })();

    tensorflow.FunctionDefLibrary = (function() {

        /**
         * Properties of a FunctionDefLibrary.
         * @memberof tensorflow
         * @interface IFunctionDefLibrary
         * @property {Array.<tensorflow.IFunctionDef>|null} ["function"] FunctionDefLibrary function
         * @property {Array.<tensorflow.IGradientDef>|null} [gradient] FunctionDefLibrary gradient
         */

        /**
         * Constructs a new FunctionDefLibrary.
         * @memberof tensorflow
         * @classdesc Represents a FunctionDefLibrary.
         * @implements IFunctionDefLibrary
         * @constructor
         * @param {tensorflow.IFunctionDefLibrary=} [properties] Properties to set
         */
        function FunctionDefLibrary(properties) {
            this["function"] = [];
            this.gradient = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FunctionDefLibrary function.
         * @member {Array.<tensorflow.IFunctionDef>} function
         * @memberof tensorflow.FunctionDefLibrary
         * @instance
         */
        FunctionDefLibrary.prototype["function"] = $util.emptyArray;

        /**
         * FunctionDefLibrary gradient.
         * @member {Array.<tensorflow.IGradientDef>} gradient
         * @memberof tensorflow.FunctionDefLibrary
         * @instance
         */
        FunctionDefLibrary.prototype.gradient = $util.emptyArray;

        /**
         * Creates a new FunctionDefLibrary instance using the specified properties.
         * @function create
         * @memberof tensorflow.FunctionDefLibrary
         * @static
         * @param {tensorflow.IFunctionDefLibrary=} [properties] Properties to set
         * @returns {tensorflow.FunctionDefLibrary} FunctionDefLibrary instance
         */
        FunctionDefLibrary.create = function create(properties) {
            return new FunctionDefLibrary(properties);
        };

        /**
         * Encodes the specified FunctionDefLibrary message. Does not implicitly {@link tensorflow.FunctionDefLibrary.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.FunctionDefLibrary
         * @static
         * @param {tensorflow.IFunctionDefLibrary} message FunctionDefLibrary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FunctionDefLibrary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message["function"] != null && message["function"].length)
                for (var i = 0; i < message["function"].length; ++i)
                    $root.tensorflow.FunctionDef.encode(message["function"][i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.gradient != null && message.gradient.length)
                for (var i = 0; i < message.gradient.length; ++i)
                    $root.tensorflow.GradientDef.encode(message.gradient[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FunctionDefLibrary message, length delimited. Does not implicitly {@link tensorflow.FunctionDefLibrary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.FunctionDefLibrary
         * @static
         * @param {tensorflow.IFunctionDefLibrary} message FunctionDefLibrary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FunctionDefLibrary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FunctionDefLibrary message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.FunctionDefLibrary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.FunctionDefLibrary} FunctionDefLibrary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunctionDefLibrary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.FunctionDefLibrary();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message["function"] && message["function"].length))
                        message["function"] = [];
                    message["function"].push($root.tensorflow.FunctionDef.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.gradient && message.gradient.length))
                        message.gradient = [];
                    message.gradient.push($root.tensorflow.GradientDef.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FunctionDefLibrary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.FunctionDefLibrary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.FunctionDefLibrary} FunctionDefLibrary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunctionDefLibrary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FunctionDefLibrary message.
         * @function verify
         * @memberof tensorflow.FunctionDefLibrary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FunctionDefLibrary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["function"] != null && message.hasOwnProperty("function")) {
                if (!Array.isArray(message["function"]))
                    return "function: array expected";
                for (var i = 0; i < message["function"].length; ++i) {
                    var error = $root.tensorflow.FunctionDef.verify(message["function"][i]);
                    if (error)
                        return "function." + error;
                }
            }
            if (message.gradient != null && message.hasOwnProperty("gradient")) {
                if (!Array.isArray(message.gradient))
                    return "gradient: array expected";
                for (var i = 0; i < message.gradient.length; ++i) {
                    var error = $root.tensorflow.GradientDef.verify(message.gradient[i]);
                    if (error)
                        return "gradient." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FunctionDefLibrary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.FunctionDefLibrary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.FunctionDefLibrary} FunctionDefLibrary
         */
        FunctionDefLibrary.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.FunctionDefLibrary)
                return object;
            var message = new $root.tensorflow.FunctionDefLibrary();
            if (object["function"]) {
                if (!Array.isArray(object["function"]))
                    throw TypeError(".tensorflow.FunctionDefLibrary.function: array expected");
                message["function"] = [];
                for (var i = 0; i < object["function"].length; ++i) {
                    if (typeof object["function"][i] !== "object")
                        throw TypeError(".tensorflow.FunctionDefLibrary.function: object expected");
                    message["function"][i] = $root.tensorflow.FunctionDef.fromObject(object["function"][i]);
                }
            }
            if (object.gradient) {
                if (!Array.isArray(object.gradient))
                    throw TypeError(".tensorflow.FunctionDefLibrary.gradient: array expected");
                message.gradient = [];
                for (var i = 0; i < object.gradient.length; ++i) {
                    if (typeof object.gradient[i] !== "object")
                        throw TypeError(".tensorflow.FunctionDefLibrary.gradient: object expected");
                    message.gradient[i] = $root.tensorflow.GradientDef.fromObject(object.gradient[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FunctionDefLibrary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.FunctionDefLibrary
         * @static
         * @param {tensorflow.FunctionDefLibrary} message FunctionDefLibrary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FunctionDefLibrary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object["function"] = [];
                object.gradient = [];
            }
            if (message["function"] && message["function"].length) {
                object["function"] = [];
                for (var j = 0; j < message["function"].length; ++j)
                    object["function"][j] = $root.tensorflow.FunctionDef.toObject(message["function"][j], options);
            }
            if (message.gradient && message.gradient.length) {
                object.gradient = [];
                for (var j = 0; j < message.gradient.length; ++j)
                    object.gradient[j] = $root.tensorflow.GradientDef.toObject(message.gradient[j], options);
            }
            return object;
        };

        /**
         * Converts this FunctionDefLibrary to JSON.
         * @function toJSON
         * @memberof tensorflow.FunctionDefLibrary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FunctionDefLibrary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FunctionDefLibrary;
    })();

    tensorflow.FunctionDef = (function() {

        /**
         * Properties of a FunctionDef.
         * @memberof tensorflow
         * @interface IFunctionDef
         * @property {tensorflow.IOpDef|null} [signature] FunctionDef signature
         * @property {Object.<string,tensorflow.IAttrValue>|null} [attr] FunctionDef attr
         * @property {Array.<tensorflow.INodeDef>|null} [nodeDef] FunctionDef nodeDef
         * @property {Object.<string,string>|null} [ret] FunctionDef ret
         */

        /**
         * Constructs a new FunctionDef.
         * @memberof tensorflow
         * @classdesc Represents a FunctionDef.
         * @implements IFunctionDef
         * @constructor
         * @param {tensorflow.IFunctionDef=} [properties] Properties to set
         */
        function FunctionDef(properties) {
            this.attr = {};
            this.nodeDef = [];
            this.ret = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FunctionDef signature.
         * @member {tensorflow.IOpDef|null|undefined} signature
         * @memberof tensorflow.FunctionDef
         * @instance
         */
        FunctionDef.prototype.signature = null;

        /**
         * FunctionDef attr.
         * @member {Object.<string,tensorflow.IAttrValue>} attr
         * @memberof tensorflow.FunctionDef
         * @instance
         */
        FunctionDef.prototype.attr = $util.emptyObject;

        /**
         * FunctionDef nodeDef.
         * @member {Array.<tensorflow.INodeDef>} nodeDef
         * @memberof tensorflow.FunctionDef
         * @instance
         */
        FunctionDef.prototype.nodeDef = $util.emptyArray;

        /**
         * FunctionDef ret.
         * @member {Object.<string,string>} ret
         * @memberof tensorflow.FunctionDef
         * @instance
         */
        FunctionDef.prototype.ret = $util.emptyObject;

        /**
         * Creates a new FunctionDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.FunctionDef
         * @static
         * @param {tensorflow.IFunctionDef=} [properties] Properties to set
         * @returns {tensorflow.FunctionDef} FunctionDef instance
         */
        FunctionDef.create = function create(properties) {
            return new FunctionDef(properties);
        };

        /**
         * Encodes the specified FunctionDef message. Does not implicitly {@link tensorflow.FunctionDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.FunctionDef
         * @static
         * @param {tensorflow.IFunctionDef} message FunctionDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FunctionDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signature != null && message.hasOwnProperty("signature"))
                $root.tensorflow.OpDef.encode(message.signature, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nodeDef != null && message.nodeDef.length)
                for (var i = 0; i < message.nodeDef.length; ++i)
                    $root.tensorflow.NodeDef.encode(message.nodeDef[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.ret != null && message.hasOwnProperty("ret"))
                for (var keys = Object.keys(message.ret), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.ret[keys[i]]).ldelim();
            if (message.attr != null && message.hasOwnProperty("attr"))
                for (var keys = Object.keys(message.attr), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.tensorflow.AttrValue.encode(message.attr[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified FunctionDef message, length delimited. Does not implicitly {@link tensorflow.FunctionDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.FunctionDef
         * @static
         * @param {tensorflow.IFunctionDef} message FunctionDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FunctionDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FunctionDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.FunctionDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.FunctionDef} FunctionDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunctionDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.FunctionDef(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signature = $root.tensorflow.OpDef.decode(reader, reader.uint32());
                    break;
                case 5:
                    reader.skip().pos++;
                    if (message.attr === $util.emptyObject)
                        message.attr = {};
                    key = reader.string();
                    reader.pos++;
                    message.attr[key] = $root.tensorflow.AttrValue.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.nodeDef && message.nodeDef.length))
                        message.nodeDef = [];
                    message.nodeDef.push($root.tensorflow.NodeDef.decode(reader, reader.uint32()));
                    break;
                case 4:
                    reader.skip().pos++;
                    if (message.ret === $util.emptyObject)
                        message.ret = {};
                    key = reader.string();
                    reader.pos++;
                    message.ret[key] = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FunctionDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.FunctionDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.FunctionDef} FunctionDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunctionDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FunctionDef message.
         * @function verify
         * @memberof tensorflow.FunctionDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FunctionDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signature != null && message.hasOwnProperty("signature")) {
                var error = $root.tensorflow.OpDef.verify(message.signature);
                if (error)
                    return "signature." + error;
            }
            if (message.attr != null && message.hasOwnProperty("attr")) {
                if (!$util.isObject(message.attr))
                    return "attr: object expected";
                var key = Object.keys(message.attr);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.tensorflow.AttrValue.verify(message.attr[key[i]]);
                    if (error)
                        return "attr." + error;
                }
            }
            if (message.nodeDef != null && message.hasOwnProperty("nodeDef")) {
                if (!Array.isArray(message.nodeDef))
                    return "nodeDef: array expected";
                for (var i = 0; i < message.nodeDef.length; ++i) {
                    var error = $root.tensorflow.NodeDef.verify(message.nodeDef[i]);
                    if (error)
                        return "nodeDef." + error;
                }
            }
            if (message.ret != null && message.hasOwnProperty("ret")) {
                if (!$util.isObject(message.ret))
                    return "ret: object expected";
                var key = Object.keys(message.ret);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.ret[key[i]]))
                        return "ret: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a FunctionDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.FunctionDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.FunctionDef} FunctionDef
         */
        FunctionDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.FunctionDef)
                return object;
            var message = new $root.tensorflow.FunctionDef();
            if (object.signature != null) {
                if (typeof object.signature !== "object")
                    throw TypeError(".tensorflow.FunctionDef.signature: object expected");
                message.signature = $root.tensorflow.OpDef.fromObject(object.signature);
            }
            if (object.attr) {
                if (typeof object.attr !== "object")
                    throw TypeError(".tensorflow.FunctionDef.attr: object expected");
                message.attr = {};
                for (var keys = Object.keys(object.attr), i = 0; i < keys.length; ++i) {
                    if (typeof object.attr[keys[i]] !== "object")
                        throw TypeError(".tensorflow.FunctionDef.attr: object expected");
                    message.attr[keys[i]] = $root.tensorflow.AttrValue.fromObject(object.attr[keys[i]]);
                }
            }
            if (object.nodeDef) {
                if (!Array.isArray(object.nodeDef))
                    throw TypeError(".tensorflow.FunctionDef.nodeDef: array expected");
                message.nodeDef = [];
                for (var i = 0; i < object.nodeDef.length; ++i) {
                    if (typeof object.nodeDef[i] !== "object")
                        throw TypeError(".tensorflow.FunctionDef.nodeDef: object expected");
                    message.nodeDef[i] = $root.tensorflow.NodeDef.fromObject(object.nodeDef[i]);
                }
            }
            if (object.ret) {
                if (typeof object.ret !== "object")
                    throw TypeError(".tensorflow.FunctionDef.ret: object expected");
                message.ret = {};
                for (var keys = Object.keys(object.ret), i = 0; i < keys.length; ++i)
                    message.ret[keys[i]] = String(object.ret[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a FunctionDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.FunctionDef
         * @static
         * @param {tensorflow.FunctionDef} message FunctionDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FunctionDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.nodeDef = [];
            if (options.objects || options.defaults) {
                object.ret = {};
                object.attr = {};
            }
            if (options.defaults)
                object.signature = null;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = $root.tensorflow.OpDef.toObject(message.signature, options);
            if (message.nodeDef && message.nodeDef.length) {
                object.nodeDef = [];
                for (var j = 0; j < message.nodeDef.length; ++j)
                    object.nodeDef[j] = $root.tensorflow.NodeDef.toObject(message.nodeDef[j], options);
            }
            var keys2;
            if (message.ret && (keys2 = Object.keys(message.ret)).length) {
                object.ret = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.ret[keys2[j]] = message.ret[keys2[j]];
            }
            if (message.attr && (keys2 = Object.keys(message.attr)).length) {
                object.attr = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.attr[keys2[j]] = $root.tensorflow.AttrValue.toObject(message.attr[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this FunctionDef to JSON.
         * @function toJSON
         * @memberof tensorflow.FunctionDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FunctionDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FunctionDef;
    })();

    tensorflow.GradientDef = (function() {

        /**
         * Properties of a GradientDef.
         * @memberof tensorflow
         * @interface IGradientDef
         * @property {string|null} [functionName] GradientDef functionName
         * @property {string|null} [gradientFunc] GradientDef gradientFunc
         */

        /**
         * Constructs a new GradientDef.
         * @memberof tensorflow
         * @classdesc Represents a GradientDef.
         * @implements IGradientDef
         * @constructor
         * @param {tensorflow.IGradientDef=} [properties] Properties to set
         */
        function GradientDef(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GradientDef functionName.
         * @member {string} functionName
         * @memberof tensorflow.GradientDef
         * @instance
         */
        GradientDef.prototype.functionName = "";

        /**
         * GradientDef gradientFunc.
         * @member {string} gradientFunc
         * @memberof tensorflow.GradientDef
         * @instance
         */
        GradientDef.prototype.gradientFunc = "";

        /**
         * Creates a new GradientDef instance using the specified properties.
         * @function create
         * @memberof tensorflow.GradientDef
         * @static
         * @param {tensorflow.IGradientDef=} [properties] Properties to set
         * @returns {tensorflow.GradientDef} GradientDef instance
         */
        GradientDef.create = function create(properties) {
            return new GradientDef(properties);
        };

        /**
         * Encodes the specified GradientDef message. Does not implicitly {@link tensorflow.GradientDef.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.GradientDef
         * @static
         * @param {tensorflow.IGradientDef} message GradientDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GradientDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.functionName != null && message.hasOwnProperty("functionName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.functionName);
            if (message.gradientFunc != null && message.hasOwnProperty("gradientFunc"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gradientFunc);
            return writer;
        };

        /**
         * Encodes the specified GradientDef message, length delimited. Does not implicitly {@link tensorflow.GradientDef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.GradientDef
         * @static
         * @param {tensorflow.IGradientDef} message GradientDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GradientDef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GradientDef message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.GradientDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.GradientDef} GradientDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GradientDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.GradientDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.functionName = reader.string();
                    break;
                case 2:
                    message.gradientFunc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GradientDef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.GradientDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.GradientDef} GradientDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GradientDef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GradientDef message.
         * @function verify
         * @memberof tensorflow.GradientDef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GradientDef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.functionName != null && message.hasOwnProperty("functionName"))
                if (!$util.isString(message.functionName))
                    return "functionName: string expected";
            if (message.gradientFunc != null && message.hasOwnProperty("gradientFunc"))
                if (!$util.isString(message.gradientFunc))
                    return "gradientFunc: string expected";
            return null;
        };

        /**
         * Creates a GradientDef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.GradientDef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.GradientDef} GradientDef
         */
        GradientDef.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.GradientDef)
                return object;
            var message = new $root.tensorflow.GradientDef();
            if (object.functionName != null)
                message.functionName = String(object.functionName);
            if (object.gradientFunc != null)
                message.gradientFunc = String(object.gradientFunc);
            return message;
        };

        /**
         * Creates a plain object from a GradientDef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.GradientDef
         * @static
         * @param {tensorflow.GradientDef} message GradientDef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GradientDef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.functionName = "";
                object.gradientFunc = "";
            }
            if (message.functionName != null && message.hasOwnProperty("functionName"))
                object.functionName = message.functionName;
            if (message.gradientFunc != null && message.hasOwnProperty("gradientFunc"))
                object.gradientFunc = message.gradientFunc;
            return object;
        };

        /**
         * Converts this GradientDef to JSON.
         * @function toJSON
         * @memberof tensorflow.GradientDef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GradientDef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GradientDef;
    })();

    return tensorflow;
})();

module.exports = $root;

},{"protobufjs/minimal":8}],20:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./compiled_api"));

},{"./compiled_api":19}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ExecutionContext = (function () {
    function ExecutionContext(weightMap) {
        this.weightMap = weightMap;
        this.rootContext = { id: 0, frameName: '', iterationId: 0 };
        this.contexts = [this.rootContext];
        this.lastId = 0;
        this.generateCurrentContextIds();
    }
    ExecutionContext.prototype.newFrame = function (id, frameName) {
        return { id: id, frameName: frameName, iterationId: 0 };
    };
    Object.defineProperty(ExecutionContext.prototype, "currentContext", {
        get: function () {
            return this.contexts;
        },
        set: function (contexts) {
            if (this.contexts !== contexts) {
                this.contexts = contexts;
                this.generateCurrentContextIds();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExecutionContext.prototype, "currentContextId", {
        get: function () {
            return this._currentContextIds[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExecutionContext.prototype, "currentContextIds", {
        get: function () {
            return this._currentContextIds;
        },
        enumerable: true,
        configurable: true
    });
    ExecutionContext.prototype.generateCurrentContextIds = function () {
        var names = [];
        for (var i = 0; i < this.contexts.length - 1; i++) {
            var contexts = this.contexts.slice(0, this.contexts.length - i);
            names.push(this.contextIdforContexts(contexts));
        }
        names.push('');
        this._currentContextIds = names;
    };
    ExecutionContext.prototype.contextIdforContexts = function (contexts) {
        return contexts ?
            contexts
                .map(function (context) { return (context.id === 0 && context.iterationId === 0) ?
                '' :
                context.frameName + "-" + context.iterationId; })
                .join('/') :
            '';
    };
    ExecutionContext.prototype.enterFrame = function (frameId) {
        if (this.contexts) {
            this.lastId++;
            this.contexts = this.contexts.slice();
            this.contexts.push(this.newFrame(this.lastId, frameId));
            this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
        }
    };
    ExecutionContext.prototype.exitFrame = function () {
        if (this.contexts && this.contexts.length > 1) {
            this.contexts = this.contexts.slice();
            this.contexts.splice(-1);
            this.currentContextIds.shift();
        }
        else {
            throw new Error('Cannot exit frame, the context is empty');
        }
    };
    ExecutionContext.prototype.nextIteration = function () {
        if (this.contexts && this.contexts.length > 0) {
            this.contexts = this.contexts.slice();
            this.lastId++;
            var context = Object.assign({}, this.contexts[this.contexts.length - 1]);
            context.iterationId += 1;
            context.id = this.lastId;
            this.contexts.splice(-1, 1, context);
            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
        }
        else {
            throw new Error('Cannot increase frame iteration, the context is empty');
        }
    };
    ExecutionContext.prototype.getWeight = function (name) {
        return this.weightMap[name];
    };
    return ExecutionContext;
}());
exports.ExecutionContext = ExecutionContext;

},{}],22:[function(require,module,exports){
(function (global){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var index_1 = require("../data/index");
var index_2 = require("../operations/index");
var graph_executor_1 = require("./graph_executor");
var FrozenModel = (function () {
    function FrozenModel(modelUrl, weightManifestUrl, requestOption) {
        this.modelUrl = modelUrl;
        this.weightManifestUrl = weightManifestUrl;
        this.requestOption = requestOption;
        this.version = 'n/a';
        this.getPathPrefix();
    }
    Object.defineProperty(FrozenModel.prototype, "modelVersion", {
        get: function () {
            return this.version;
        },
        enumerable: true,
        configurable: true
    });
    FrozenModel.prototype.getPathPrefix = function () {
        var isAbsolute = /^[a-z][a-z0-9+.-]*:/.test(this.weightManifestUrl);
        if (isAbsolute) {
            var url = new URL(this.weightManifestUrl);
            var segments = url.pathname.split('/');
            segments.splice(-1);
            url.pathname = segments.join('/');
            this.pathPrefix = url.toString();
        }
        else {
            var segments = this.weightManifestUrl.split('/');
            segments.splice(-1);
            this.pathPrefix = segments.join('/');
        }
    };
    FrozenModel.prototype.loadRemoteProtoFile = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response, _a, _b, _c, error_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 3, , 4]);
                        return [4, fetch(this.modelUrl, this.requestOption)];
                    case 1:
                        response = _d.sent();
                        _b = (_a = index_1.tensorflow.GraphDef).decode;
                        _c = Uint8Array.bind;
                        return [4, response.arrayBuffer()];
                    case 2: return [2, _b.apply(_a, [new (_c.apply(Uint8Array, [void 0, _d.sent()]))()])];
                    case 3:
                        error_1 = _d.sent();
                        throw new Error(this.modelUrl + " not found. " + error_1);
                    case 4: return [2];
                }
            });
        });
    };
    FrozenModel.prototype.loadWeightManifest = function () {
        return __awaiter(this, void 0, void 0, function () {
            var manifest, _a, error_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 3, , 4]);
                        return [4, fetch(this.weightManifestUrl, this.requestOption)];
                    case 1:
                        manifest = _b.sent();
                        _a = this;
                        return [4, manifest.clone().json()];
                    case 2:
                        _a.weightManifest = _b.sent();
                        return [3, 4];
                    case 3:
                        error_2 = _b.sent();
                        throw new Error(this.weightManifestUrl + " not found. " + error_2);
                    case 4: return [2];
                }
            });
        });
    };
    FrozenModel.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var graphPromise, manifestPromise, _a, graph, weightMap;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        graphPromise = this.loadRemoteProtoFile();
                        manifestPromise = this.loadWeightManifest();
                        return [4, Promise.all([graphPromise, manifestPromise])];
                    case 1:
                        _a = __read.apply(void 0, [_b.sent(), 1]), graph = _a[0];
                        this.version = graph.versions.producer + "." + graph.versions.minConsumer;
                        return [4, tfc.io.loadWeights(this.weightManifest, this.pathPrefix, undefined, this.requestOption)];
                    case 2:
                        weightMap = _b.sent();
                        this.executor =
                            new graph_executor_1.GraphExecutor(index_2.OperationMapper.Instance.transformGraph(graph));
                        this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
                        return [2, true];
                }
            });
        });
    };
    FrozenModel.prototype.execute = function (inputs, outputs) {
        if (this.executor.isControlFlowModel) {
            throw new Error('The model contains control flow ops, ' +
                'please use executeAsync method');
        }
        var result = this.executor.execute(this.convertTensorMapToTensorsMap(inputs), outputs);
        var keys = Object.keys(result);
        return (keys.length === 1) ? result[keys[0]] : result;
    };
    FrozenModel.prototype.executeAsync = function (inputs, outputs) {
        return __awaiter(this, void 0, void 0, function () {
            var result, keys;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.executor.isControlFlowModel) {
                            throw new Error('The model does not contain control flow ops, ' +
                                'please use execute method for better performance.');
                        }
                        return [4, this.executor.executeAsync(this.convertTensorMapToTensorsMap(inputs), outputs)];
                    case 1:
                        result = _a.sent();
                        keys = Object.keys(result);
                        return [2, (keys.length === 1) ? result[keys[0]] : result];
                }
            });
        });
    };
    FrozenModel.prototype.convertTensorMapToTensorsMap = function (map) {
        return Object.keys(map).reduce(function (newMap, key) {
            newMap[key] = [map[key]];
            return newMap;
        }, {});
    };
    FrozenModel.prototype.dispose = function () {
        this.executor.dispose();
    };
    return FrozenModel;
}());
exports.FrozenModel = FrozenModel;
function loadFrozenModel(modelUrl, weightsManifestUrl, requestOption) {
    return __awaiter(this, void 0, void 0, function () {
        var model;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    model = new FrozenModel(modelUrl, weightsManifestUrl, requestOption);
                    return [4, model.load()];
                case 1:
                    _a.sent();
                    return [2, model];
            }
        });
    });
}
exports.loadFrozenModel = loadFrozenModel;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../data/index":20,"../operations/index":40,"./graph_executor":23}],23:[function(require,module,exports){
(function (global){
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("../operations/executors/utils");
var operations = require("../operations/index");
var execution_context_1 = require("./execution_context");
var GraphExecutor = (function () {
    function GraphExecutor(graph) {
        this.graph = graph;
        this.compiledOrder = [];
        this._weightMap = {};
        this.placeholders = graph.placeholders.map(function (node) { return node.name; });
        this.outputs = graph.outputs.map(function (node) { return node.name; });
        this.compile();
    }
    Object.defineProperty(GraphExecutor.prototype, "weightMap", {
        get: function () {
            return this._weightMap;
        },
        set: function (weightMap) {
            var weightIds = Object.keys(weightMap).map(function (key) { return weightMap[key].map(function (tensor) { return tensor.id; }); });
            this.weightIds = [].concat.apply([], weightIds);
            this._weightMap = weightMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "inputNodes", {
        get: function () {
            return this.placeholders;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "outputNodes", {
        get: function () {
            return this.outputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "isControlFlowModel", {
        get: function () {
            return this.graph.withControlFlow;
        },
        enumerable: true,
        configurable: true
    });
    GraphExecutor.prototype.compile = function () {
        if (this.graph.withControlFlow) {
            return;
        }
        var stack = __spread(this.graph.inputs);
        var visited = {};
        while (stack.length > 0) {
            var node = stack.pop();
            visited[node.name] = true;
            this.compiledOrder.push(node);
            node.children.forEach(function (childNode) {
                if (!visited[childNode.name] && childNode.inputNames.every(function (name) {
                    var _a = __read(utils_1.getNodeNameAndIndex(name), 1), nodeName = _a[0];
                    return visited[nodeName];
                })) {
                    stack.push(childNode);
                }
            });
        }
    };
    GraphExecutor.prototype.execute = function (inputs, outputs) {
        var _this = this;
        this.checkInput(inputs);
        var result = tfjs_core_1.tidy(function () {
            var context = new execution_context_1.ExecutionContext(_this._weightMap);
            var tensors = _this.compiledOrder.reduce(function (map, node) {
                map[node.name] =
                    operations.executeOp(node, map, context);
                return map;
            }, __assign({}, _this.weightMap, inputs));
            return _this.findOutputs(tensors, context, outputs);
        });
        return result;
    };
    GraphExecutor.prototype.executeAsync = function (inputs, outputs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var context, tensors, results, outputIds, inputIdArray, inputIds;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        context = new execution_context_1.ExecutionContext(this._weightMap);
                        return [4, this.executeWithControlFlow(inputs, context)];
                    case 1:
                        tensors = _a.sent();
                        results = this.findOutputs(tensors, context, outputs);
                        outputIds = Object.keys(results).map(function (key) { return results[key].id; });
                        inputIdArray = Object.keys(inputs).map(function (key) { return inputs[key].map(function (input) { return input.id; }); });
                        inputIds = [].concat.apply([], inputIdArray);
                        Object.keys(tensors).forEach(function (key) {
                            var tensorArray = tensors[key];
                            tensorArray.forEach(function (tensor) {
                                if (tensor && outputIds.indexOf(tensor.id) === -1 &&
                                    inputIds.indexOf(tensor.id) === -1 &&
                                    _this.weightIds.indexOf(tensor.id) === -1) {
                                    tensor.dispose();
                                }
                            });
                        });
                        return [2, results];
                }
            });
        });
    };
    GraphExecutor.prototype.executeWithControlFlow = function (inputs, context) {
        return __awaiter(this, void 0, void 0, function () {
            var stack, tensorMap, added, item, tensors, _a, nodeName, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        stack = this.graph.inputs.map(function (node) {
                            return { node: node, contexts: context.currentContext };
                        });
                        tensorMap = __assign({}, this.weightMap, inputs);
                        added = {};
                        _d.label = 1;
                    case 1:
                        if (!(stack.length > 0)) return [3, 3];
                        item = stack.pop();
                        context.currentContext = item.contexts;
                        tensors = operations.executeOp(item.node, tensorMap, context);
                        _a = __read(utils_1.getNodeNameAndIndex(item.node.name, context), 1), nodeName = _a[0];
                        _b = tensorMap;
                        _c = nodeName;
                        return [4, tensors];
                    case 2:
                        _b[_c] = _d.sent();
                        item.node.children.forEach(function (childNode) {
                            var _a = __read(utils_1.getNodeNameAndIndex(childNode.name, context), 1), nodeName = _a[0];
                            if (!added[nodeName]) {
                                if (childNode.op === 'merge') {
                                    if (childNode.inputNames.some(function (name) {
                                        return !!utils_1.getTensor(name, tensorMap, context);
                                    })) {
                                        added[nodeName] = true;
                                        stack.push({ contexts: context.currentContext, node: childNode });
                                    }
                                }
                                else if (childNode.inputNames.every(function (name) {
                                    return !!utils_1.getTensor(name, tensorMap, context);
                                })) {
                                    added[nodeName] = true;
                                    stack.push({ contexts: context.currentContext, node: childNode });
                                }
                            }
                        });
                        return [3, 1];
                    case 3: return [2, tensorMap];
                }
            });
        });
    };
    GraphExecutor.prototype.findOutputs = function (tensorMap, context, outputs) {
        if (outputs && !(outputs instanceof Array)) {
            outputs = [outputs];
        }
        var requestedOutputs = (outputs || this.graph.outputs.map(function (node) { return node.name; }));
        return requestedOutputs.reduce(function (map, name) {
            map[name] = utils_1.getTensor(name, tensorMap, context);
            return map;
        }, {});
    };
    GraphExecutor.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.weightMap)
            .forEach(function (key) { return _this.weightMap[key].forEach(function (tensor) { return tensor.dispose(); }); });
    };
    GraphExecutor.prototype.checkInput = function (inputs) {
        var _this = this;
        var inputKeys = Object.keys(inputs);
        var missing = [];
        var extra = [];
        this.placeholders.forEach(function (name) {
            if (inputKeys.indexOf(name) === -1)
                missing.push(name);
        });
        inputKeys.forEach(function (name) {
            if (_this.placeholders.indexOf(name) === -1)
                extra.push(name);
        });
        if (missing.length > 0) {
            throw new Error("Missing input placeholders: " + missing);
        }
        if (extra.length > 0) {
            throw new Error("Extra input tensors: " + extra);
        }
    };
    return GraphExecutor;
}());
exports.GraphExecutor = GraphExecutor;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../operations/executors/utils":39,"../operations/index":40,"./execution_context":21}],24:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./graph_executor"));
__export(require("./frozen_model"));
__export(require("./execution_context"));

},{"./execution_context":21,"./frozen_model":22,"./graph_executor":23}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("./executor/index");
exports.FrozenModel = index_1.FrozenModel;
exports.loadFrozenModel = index_1.loadFrozenModel;
var version_1 = require("./version");
exports.version_converter = version_1.version;

},{"./executor/index":24,"./version":56}],26:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'add': {
            return [tfc.add(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'mul':
            return [tfc.mul(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        case 'div': {
            return [tfc.div(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'sub': {
            return [tfc.sub(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'minimum': {
            return [tfc.minimum(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'maximum': {
            return [tfc.maximum(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'pow': {
            return [tfc.pow(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'squaredDifference': {
            return [tfc.squaredDifference(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'arithmetic';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],27:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'abs':
            return [tfc.abs(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'acos':
            return [tfc.acos(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'asin':
            return [tfc.asin(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'atan':
            return [tfc.atan(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'ceil':
            return [tfc.ceil(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'cos':
            return [tfc.cos(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'cosh':
            return [tfc.cosh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'elu':
            return [tfc.elu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'exp':
            return [tfc.exp(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'floor':
            return [tfc.floor(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'log':
            return [tfc.log(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'neg':
            return [tfc.neg(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'relu':
            return [tfc.relu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'selu':
            return [tfc.selu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sigmoid':
            return [tfc.sigmoid(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sin':
            return [tfc.sin(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sinh': {
            return [tfc.sinh(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'sqrt': {
            return [tfc.sqrt(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'square': {
            return [tfc.square(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'tanh': {
            return [tfc.tanh(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'tan':
            return [tfc.tan(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'clipByValue':
            return [tfc.clipByValue(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('clipValueMin', node, tensorMap, context), utils_1.getParamValue('clipValueMax', node, tensorMap, context))];
        case 'rsqrt':
            return [tfc.div(tfc.scalar(1.0, 'float32'), tfc.sqrt(utils_1.getTensor(node.inputNames[0], tensorMap, context)))];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'basic_math';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],28:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) { return __awaiter(_this, void 0, void 0, function () {
    var _a, pred, data_1, inputName, frameId, data, tensor, input;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _a = node.op;
                switch (_a) {
                    case 'loopCond': return [3, 1];
                    case 'switch': return [3, 2];
                    case 'merge': return [3, 4];
                    case 'enter': return [3, 5];
                    case 'exit': return [3, 6];
                    case 'nextIteration': return [3, 7];
                }
                return [3, 8];
            case 1: return [2, [utils_1.getParamValue('pred', node, tensorMap, context)]];
            case 2:
                pred = utils_1.getParamValue('pred', node, tensorMap, context);
                data_1 = utils_1.getParamValue('data', node, tensorMap, context);
                return [4, pred.data()];
            case 3: return [2, (_b.sent())[0] ? [undefined, data_1] : [data_1, undefined]];
            case 4:
                inputName = node.inputNames.find(function (name) { return utils_1.getTensor(name, tensorMap, context) !== undefined; });
                return [2, inputName ? [utils_1.getTensor(inputName, tensorMap, context)] : undefined];
            case 5:
                frameId = utils_1.getParamValue('frameName', node, tensorMap, context);
                data = utils_1.getParamValue('tensor', node, tensorMap, context);
                context.enterFrame(frameId);
                return [2, [data]];
            case 6:
                tensor = utils_1.getParamValue('tensor', node, tensorMap, context);
                context.exitFrame();
                return [2, [tensor]];
            case 7:
                input = utils_1.getParamValue('tensor', node, tensorMap, context);
                context.nextIteration();
                return [2, [input]];
            case 8: throw TypeError("Node type " + node.op + " is not implemented");
        }
    });
}); };
exports.CATEGORY = 'control';

},{"./utils":39}],29:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'conv1d': {
            var stride = utils_1.getParamValue('stride', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            var dilation = utils_1.getParamValue('dilation', node, tensorMap, context);
            return [tfc.conv1d(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];
        }
        case 'conv2d': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            var dilations = utils_1.getParamValue('dilations', node, tensorMap, context);
            return [tfc.conv2d(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])];
        }
        case 'conv2dTranspose': {
            var shape = utils_1.getParamValue('outputShape', node, tensorMap, context);
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            return [tfc.conv2dTranspose(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), shape, [stride[1], stride[2]], pad)];
        }
        case 'depthwiseConv2d': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dilations = utils_1.getParamValue('dilations', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            return [tfc.depthwiseConv2d(utils_1.getParamValue('input', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])];
        }
        case 'avgPool': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var kernelSize = utils_1.getParamValue('kernelSize', node, tensorMap, context);
            return [tfc.avgPool(utils_1.getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];
        }
        case 'maxPool': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var kernelSize = utils_1.getParamValue('kernelSize', node, tensorMap, context);
            return [tfc.maxPool(utils_1.getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'convolution';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],30:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'fill': {
            var shape = utils_1.getParamValue('shape', node, tensorMap, context);
            var value = utils_1.getParamValue('value', node, tensorMap, context);
            return [tfc.fill(shape, value)];
        }
        case 'linspace': {
            var start = utils_1.getParamValue('start', node, tensorMap, context);
            var stop_1 = utils_1.getParamValue('stop', node, tensorMap, context);
            var num = utils_1.getParamValue('num', node, tensorMap, context);
            return [tfc.linspace(start, stop_1, num)];
        }
        case 'oneHot': {
            var indices = utils_1.getParamValue('indices', node, tensorMap, context);
            var depth = utils_1.getParamValue('depth', node, tensorMap, context);
            var onValue = utils_1.getParamValue('onValue', node, tensorMap, context);
            var offValue = utils_1.getParamValue('offValue', node, tensorMap, context);
            return [tfc.oneHot(indices, depth, onValue, offValue)];
        }
        case 'ones': {
            return [tfc.ones(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'onesLike': {
            return [tfc.onesLike(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'randomUniform': {
            return [tfc.randomUniform(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('minval', node, tensorMap, context), utils_1.getParamValue('maxval', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'range': {
            var start = utils_1.getParamValue('start', node, tensorMap, context);
            var stop_2 = utils_1.getParamValue('stop', node, tensorMap, context);
            var step = utils_1.getParamValue('step', node, tensorMap, context);
            return [tfc.range(start, stop_2, step, utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'truncatedNormal': {
            var shape = utils_1.getParamValue('shape', node, tensorMap, context);
            var mean = utils_1.getParamValue('mean', node, tensorMap, context);
            var stdDev = utils_1.getParamValue('stdDev', node, tensorMap, context);
            var seed = utils_1.getParamValue('seed', node, tensorMap, context);
            return [tfc.truncatedNormal(shape, mean, stdDev, utils_1.getParamValue('dtype', node, tensorMap, context), seed)];
        }
        case 'zeros': {
            return [tfc.zeros(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'zerosLike': {
            return [tfc.zerosLike(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'creation';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],31:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'const': {
            return tensorMap[node.name];
        }
        case 'placeholder':
            var def = utils_1.getParamValue('default', node, tensorMap, context);
            return [utils_1.getTensor(node.name, tensorMap, context) || def];
        case 'identity':
        case 'stopGradient':
            return [utils_1.getParamValue('x', node, tensorMap, context)];
        case 'shape':
            return [tfc.tensor1d(utils_1.getParamValue('x', node, tensorMap, context).shape, 'int32')];
        case 'noop':
            return [];
        case 'print':
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            var data = utils_1.getParamValue('data', node, tensorMap, context);
            var message = utils_1.getParamValue('message', node, tensorMap, context);
            var summarize = utils_1.getParamValue('summarize', node, tensorMap, context);
            console.warn('The graph has a tf.print() operation,' +
                'usually used for debugging, which slows down performance.');
            console.log(message);
            for (var i = 0; i < data.length; i++) {
                console.log(Array.prototype.slice.call(data[0].dataSync()).slice(0, summarize));
            }
            return [input];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'graph';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],32:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'resizeBilinear': {
            var images = utils_1.getParamValue('images', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            var alignCorners = utils_1.getParamValue('alignCorners', node, tensorMap, context);
            return [tfc.image.resizeBilinear(images, [size[0], size[1]], alignCorners)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'image';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],33:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'equal': {
            return [tfc.equal(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'greater': {
            return [tfc.greater(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'greaterEqual': {
            return [tfc.greaterEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'less': {
            return [tfc.less(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'lessEqual': {
            return [tfc.lessEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'logicalAnd': {
            return [tfc.logicalAnd(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'logicalNot': {
            return [tfc.logicalNot(utils_1.getParamValue('a', node, tensorMap, context))];
        }
        case 'logicalOr': {
            return [tfc.logicalOr(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'where': {
            return [tfc.where(utils_1.getParamValue('condition', node, tensorMap, context), utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'logical';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],34:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'matMul':
            return [tfc.matMul(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context), utils_1.getParamValue('transposeA', node, tensorMap, context), utils_1.getParamValue('transposeB', node, tensorMap, context))];
        case 'transpose':
            return [tfc.transpose(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('perm', node, tensorMap, context))];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'matrices';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],35:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'batchNormalization': {
            return [tfc.batchNormalization(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('mean', node, tensorMap, context), utils_1.getParamValue('variance', node, tensorMap, context), utils_1.getParamValue('epislon', node, tensorMap, context), utils_1.getParamValue('scale', node, tensorMap, context), utils_1.getParamValue('offset', node, tensorMap, context))];
        }
        case 'localResponseNormalization': {
            return [tfc.localResponseNormalization(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('radius', node, tensorMap, context), utils_1.getParamValue('bias', node, tensorMap, context), utils_1.getParamValue('alpha', node, tensorMap, context), utils_1.getParamValue('beta', node, tensorMap, context))];
        }
        case 'softmax': {
            return [tfc.softmax(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'normalization';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],36:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'max': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.max(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'mean': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.mean(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'min': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.min(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'sum': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.sum(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'argMax': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.argMax(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'argMin': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.argMin(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'reduction';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],37:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'concat': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var inputs = utils_1.getParamValue('tensors', node, tensorMap, context);
            return [tfc.concat(inputs, axis)];
        }
        case 'gather': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            var indices = utils_1.getParamValue('indices', node, tensorMap, context);
            return [tfc.gather(input, indices, axis)];
        }
        case 'reverse': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            return [tfc.reverse(input, axis)];
        }
        case 'slice': {
            var begin = utils_1.getParamValue('begin', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            return [tfc.slice(utils_1.getParamValue('x', node, tensorMap, context), begin, size)];
        }
        case 'stack': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.stack(utils_1.getParamValue('tensors', node, tensorMap, context), axis)];
        }
        case 'tile': {
            var reps = utils_1.getParamValue('reps', node, tensorMap, context);
            return [tfc.tile(utils_1.getParamValue('x', node, tensorMap, context), reps)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'slice_join';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],38:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = (typeof window !== "undefined" ? window['tfc'] : typeof global !== "undefined" ? global['tfc'] : null);
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'cast': {
            return [tfc.cast(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'expandDims': {
            var axis = node.params['axis'].value;
            return [tfc.expandDims(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'squeeze': {
            var axis = node.params['axis'].value;
            return [tfc.squeeze(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'reshape': {
            return [tfc.reshape(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('shape', node, tensorMap, context))];
        }
        case 'pad': {
            return [tfc.pad(utils_1.getParamValue('x', node, tensorMap, context), utils_1.split(utils_1.getParamValue('padding', node, tensorMap, context), 2), utils_1.getParamValue('constantValue', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'transformation';

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":39}],39:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
function getParamValue(paramName, node, tensorMap, context) {
    var param = node.params[paramName];
    if (param && param.inputIndex !== undefined) {
        if (param.type === 'tensor') {
            return getTensor(node.inputNames[param.inputIndex], tensorMap, context);
        }
        if (param.type === 'tensors') {
            var inputs = param.inputIndex === 0 ?
                node.inputNames.slice(param.inputIndex, -param.inputParamLength) :
                node.inputNames.splice(param.inputIndex);
            return inputs.map(function (name) { return getTensor(name, tensorMap, context); });
        }
        var data = Array.prototype.slice.call(getTensor(node.inputNames.slice(param.inputIndex)[0], tensorMap, context)
            .dataSync());
        return param.type === 'number' ? data[0] : data;
    }
    return param && param.value;
}
exports.getParamValue = getParamValue;
function getTensor(name, tensorsMap, context) {
    var _a = __read(parseNodeName(name), 2), nodeName = _a[0], index = _a[1];
    var contextId = context.currentContextIds.find(function (contextId) {
        return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];
    });
    return contextId !== undefined ?
        tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] :
        undefined;
}
exports.getTensor = getTensor;
function getNodeNameAndIndex(inputName, context) {
    var _a = __read(parseNodeName(inputName), 2), nodeName = _a[0], index = _a[1];
    return [
        getNodeNameWithContextId(nodeName, context && context.currentContextId),
        index
    ];
}
exports.getNodeNameAndIndex = getNodeNameAndIndex;
function getNodeNameWithContextId(name, contextId) {
    return !!contextId ? name + "-" + contextId : name;
}
function parseNodeName(name) {
    var index = name.lastIndexOf(':');
    if (index === -1)
        return [name, 0];
    var nodeName = name.substring(0, index);
    return [nodeName, Number(name.substring(index + 1))];
}
exports.parseNodeName = parseNodeName;
function split(arr, size) {
    var res = [];
    for (var i = 0; i < arr.length; i += size) {
        res.push(arr.slice(i, i + size));
    }
    return res;
}
exports.split = split;

},{}],40:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./operation_mapper"));
__export(require("./operation_executor"));

},{"./operation_executor":54,"./operation_mapper":55}],41:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Add",
    "dlOpName": "add",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "BiasAdd",
    "dlOpName": "add",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sub",
    "dlOpName": "sub",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "RealDiv",
    "dlOpName": "div",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Div",
    "dlOpName": "div",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Mul",
    "dlOpName": "mul",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Maximum",
    "dlOpName": "maximum",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Minimum",
    "dlOpName": "minimum",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Pow",
    "dlOpName": "pow",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "SquaredDifference",
    "dlOpName": "squaredDifference",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      }
    ]
  }
]

},{}],42:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Abs",
    "dlOpName": "abs",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Acos",
    "dlOpName": "acos",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Asin",
    "dlOpName": "asin",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "atan",
    "dlOpName": "atan",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Ceil",
    "dlOpName": "ceil",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "ClipByValue",
    "dlOpName": "clipByValue",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "clip_value_min",
        "dlParamName": "clipValueMin",
        "type": "number"
      },
      {
        "tfParamName": "clip_value_max",
        "dlParamName": "clipValueMax",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Cos",
    "dlOpName": "cos",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Cosh",
    "dlOpName": "cosh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Elu",
    "dlOpName": "elu",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Exp",
    "dlOpName": "exp",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Floor",
    "dlOpName": "floor",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Log",
    "dlOpName": "log",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Neg",
    "dlOpName": "neg",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Relu",
    "dlOpName": "relu",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Relu6",
    "dlOpName": "clipByValue",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "dlParamName": "clipValueMin",
        "type": "number",
        "defaultValue": 0
      },
      {
        "dlParamName": "clipValueMax",
        "type": "number",
        "defaultValue": 6
      }
    ]
  },
  {
    "tfOpName": "Selu",
    "dlOpName": "selu",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sigmoid",
    "dlOpName": "sigmoid",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sin",
    "dlOpName": "sin",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sinh",
    "dlOpName": "sinh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sqrt",
    "dlOpName": "sqrt",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Rsqrt",
    "dlOpName": "rsqrt",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Square",
    "dlOpName": "square",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Tan",
    "dlOpName": "tan",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Tanh",
    "dlOpName": "tanh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],43:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "LoopCond",
    "dlOpName": "loopCond",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "pred",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Switch",
    "dlOpName": "switch",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "data",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "pred",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Merge",
    "dlOpName": "merge",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "tfInputParamLength": 0,
        "dlParamName": "tensors",
        "type": "tensors"
      }
    ]
  },
  {
    "tfOpName": "Enter",
    "dlOpName": "enter",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "tensor",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "frame_name",
        "dlParamName": "frameName",
        "type": "string"
      },
      {
        "tfParamName": "is_constant",
        "dlParamName": "isConstant",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Exit",
    "dlOpName": "exit",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "tensor",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "NextIteration",
    "dlOpName": "nextIteration",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "tensor",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],44:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "AvgPool",
    "dlOpName": "avgPool",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfParamName": "ksize",
        "dlParamName": "kernelSize",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "MaxPool",
    "dlOpName": "maxPool",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfParamName": "ksize",
        "dlParamName": "kernelSize",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Conv1D",
    "dlOpName": "conv1d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "stride",
        "dlParamName": "stride",
        "type": "number"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NWC"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "dilation",
        "dlParamName": "dilation",
        "type": "number",
        "defaultValue": 1
      }
    ]
  },
  {
    "tfOpName": "Conv2D",
    "dlOpName": "conv2d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "useCudnnOnGpu",
        "dlParamName": "useCudnnOnGpu",
        "type": "bool"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfParamName": "dilations",
        "dlParamName": "dilations",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Conv2DTranspose",
    "dlOpName": "conv2dTranspose",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "output_shape",
        "dlParamName": "outputShape",
        "type": "number[]"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "DepthwiseConv2d",
    "dlOpName": "depthwiseConv2d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "input",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfParamName": "dilations",
        "dlParamName": "dilations",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "DepthwiseConv2dNative",
    "dlOpName": "depthwiseConv2d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "input",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfParamName": "dilations",
        "dlParamName": "dilations",
        "type": "number[]"
      }
    ]
  }
]

},{}],45:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Fill",
    "dlOpName": "fill",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "value",
        "type": "number"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LinSpace",
    "dlOpName": "linspace",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "start",
        "type": "number"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "stop",
        "type": "number"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "num",
        "type": "number"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "OneHot",
    "dlOpName": "oneHot",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "indices",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "depth",
        "type": "number"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "onValue",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "offValue",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "notSupported": true
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Ones",
    "dlOpName": "ones",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "OnesLike",
    "dlOpName": "onesLike",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "dtype",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "RandomUniform",
    "dlOpName": "randomUniform",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "minval",
        "dlParamName": "minval",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "maxval",
        "dlParamName": "maxval",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfParamName": "dtype",
        "dlParamName": "dtype",
        "type": "dtype"
      },
      {
        "tfParamName": "seed",
        "dlParamName": "seed",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "seed2",
        "dlParamName": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      {
        "tfParamName": "T",
        "dlParamName": "T",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Range",
    "dlOpName": "range",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "start",
        "type": "number"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "stop",
        "type": "number"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "step",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "Tidx",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "truncatedNormal",
    "dlOpName": "truncatedNormal",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "means",
        "dlParamName": "mean",
        "type": "number",
        "defaultValue": 0.0
      },
      {
        "tfParamName": "stddev",
        "dlParamName": "stdDev",
        "type": "number",
        "defaultValue": 1.0
      },
      {
        "tfParamName": "seed",
        "dlParamName": "seed",
        "type": "number"
      },
      {
        "tfParamName": "seed2",
        "dlParamName": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      {
        "tfParamName": "dtype",
        "dlParamName": "dtype",
        "type": "dtype"
      },
      {
        "tfParamName": "T",
        "dlParamName": "T",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Zeros",
    "dlOpName": "zeros",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "ZerosLike",
    "dlOpName": "zerosLike",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  }
]

},{}],46:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "PlaceholderWithDefault",
    "dlOpName": "placeholder",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "default",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Placeholder",
    "dlOpName": "placeholder",
    "category": "graph"
  },
  {
    "tfOpName": "Const",
    "dlOpName": "const",
    "category": "graph"
  },
  {
    "tfOpName": "Identity",
    "dlOpName": "identity",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Shape",
    "dlOpName": "shape",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Print",
    "dlOpName": "print",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "tfInputParamLength": 1,
        "dlParamName": "data",
        "type": "tensors"
      },
      {
        "tfParamName": "message",
        "dlParamName": "message",
        "type": "string"
      },
      {
        "tfParamName": "first_n",
        "dlParamName": "firstN",
        "type": "number",
        "notSupprted": true
      },
      {
        "tfParamName": "summarize",
        "dlParamName": "summarize",
        "type": "number",
        "defaultValue": 3
      }
    ]
  },
  {
    "tfOpName": "NoOp",
    "dlOpName": "noop",
    "category": "graph",
    "params": []
  },
  {
    "tfOpName": "StopGradient",
    "dlOpName": "stopGradient",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  }
]

},{}],47:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "ResizeBilinear",
    "dlOpName": "resizeBilinear",
    "category": "image",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "images",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "size",
        "type": "number[]"
      },
      {
        "tfParamName": "align_corners",
        "dlParamName": "alignCorners",
        "type": "bool"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],48:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Equal",
    "dlOpName": "equal",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Greater",
    "dlOpName": "greater",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "GreaterEqual",
    "dlOpName": "greaterEqual",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Less",
    "dlOpName": "less",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LessEqual",
    "dlOpName": "lessEqual",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalAnd",
    "dlOpName": "logicalAnd",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalNot",
    "dlOpName": "logicalNot",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalOr",
    "dlOpName": "logicalOr",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Select",
    "dlOpName": "where",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "condition",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],49:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "MatMul",
    "dlOpName": "matMul",
    "category": "matrices",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "transpose_a",
        "dlParamName": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfParamName": "transpose_b",
        "dlParamName": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Transpose",
    "dlOpName": "transpose",
    "category": "matrices",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "perm",
        "dlParamName": "perm",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],50:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "FusedBatchNorm",
    "dlOpName": "batchNormalization",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "scale",
        "type": "tensor"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "offset",
        "type": "tensor"
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "mean",
        "type": "tensor"
      },
      {
        "tfInputIndex": 4,
        "dlParamName": "variance",
        "type": "tensor"
      },
      {
        "tfParamName": "epislon",
        "dlParamName": "epislon",
        "type": "number",
        "defaultValue": 0.001
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "FusedBatchNormV2",
    "dlOpName": "batchNormalization",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "scale",
        "type": "tensor"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "offset",
        "type": "tensor"
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "mean",
        "type": "tensor"
      },
      {
        "tfInputIndex": 4,
        "dlParamName": "variance",
        "type": "tensor"
      },
      {
        "tfParamName": "epislon",
        "dlParamName": "epislon",
        "type": "number",
        "defaultValue": 0.001
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LRN",
    "dlOpName": "localResponseNormalization",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "depth_radius",
        "dlParamName": "radius",
        "type": "number",
        "defaultValue": 5
      },
      {
        "tfParamName": "bias",
        "dlParamName": "bias",
        "type": "number",
        "defaultValue": 1.0
      },
      {
        "tfParamName": "alpha",
        "dlParamName": "alpha",
        "type": "number",
        "defaultValue": 1.0
      },
      {
        "tfParamName": "beta",
        "dlParamName": "beta",
        "type": "number",
        "defaultValue": 0.5
      }
    ]
  },  {
    "tfOpName": "Softmax",
    "dlOpName": "softmax",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  }
]

},{}],51:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Max",
    "dlOpName": "max",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Mean",
    "dlOpName": "mean",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Min",
    "dlOpName": "min",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Sum",
    "dlOpName": "sum",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "ArgMax",
    "dlOpName": "argMax",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "ArgMin",
    "dlOpName": "argMin",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  }
]

},{}],52:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "ConcatV2",
    "dlOpName": "concat",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 0,
        "tfInputParamLength": 1,
        "dlParamName": "tensors",
        "type": "tensors"
      },
      {
        "tfInputIndex": -1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Concat",
    "dlOpName": "concat",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 1,
        "tfInputParamLength": 1,
        "dlParamName": "tensors",
        "type": "tensors"
      },
      {
        "tfInputIndex": 0,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "GatherV2",
    "dlOpName": "gather",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "indices",
        "type": "tensor"
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Gather",
    "dlOpName": "gather",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "indices",
        "type": "tensor"
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "validate_indices",
        "dlParamName": "validateIndices",
        "type": "bool",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Reverse",
    "dlOpName": "reverse",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "ReverseV2",
    "dlOpName": "reverse",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Slice",
    "dlOpName": "slice",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "begin",
        "type": "number[]"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "size",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Pack",
    "dlOpName": "stack",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "tfInputParamLength": 0,
        "dlParamName": "tensors",
        "type": "tensors"
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Tile",
    "dlOpName": "tile",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "reps",
        "type": "number[]"
      }
    ]
  }
]

},{}],53:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Cast",
    "dlOpName": "cast",
    "category": "transformation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "SrcT",
        "dlParamName": "sdtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "DstT",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "ExpandDims",
    "dlOpName": "expandDims",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "tfParamNameDeprecated": "dim",
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Pad",
    "dlOpName": "pad",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "padding",
        "type": "number[]"
      },
      {
        "tfParamName": "constant_value",
        "dlParamName": "constantValue",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "PadV2",
    "dlOpName": "pad",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "padding",
        "type": "number[]"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "constantValue",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Reshape",
    "dlOpName": "reshape",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "shape",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Squeeze",
    "dlOpName": "squeeze",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "axis",
        "tfParamNameDeprecated": "squeeze_dims",
        "dlParamName": "axis",
        "type": "number[]"
      }
    ]
  }
]

},{}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var arithmetic = require("./executors/arithmetic_executor");
var basicMath = require("./executors/basic_math_executor");
var control = require("./executors/control_executor");
var convolution = require("./executors/convolution_executor");
var creation = require("./executors/creation_executor");
var graph = require("./executors/graph_executor");
var image = require("./executors/image_executor");
var logical = require("./executors/logical_executor");
var matrices = require("./executors/matrices_executor");
var normalization = require("./executors/normalization_executor");
var reduction = require("./executors/reduction_executor");
var sliceJoin = require("./executors/slice_join_executor");
var transformation = require("./executors/transformation_executor");
function executeOp(node, tensorMap, context) {
    switch (node.category) {
        case 'arithmetic':
            return arithmetic.executeOp(node, tensorMap, context);
        case 'basic_math':
            return basicMath.executeOp(node, tensorMap, context);
        case 'control':
            return control.executeOp(node, tensorMap, context);
        case 'convolution':
            return convolution.executeOp(node, tensorMap, context);
        case 'creation':
            return creation.executeOp(node, tensorMap, context);
        case 'image':
            return image.executeOp(node, tensorMap, context);
        case 'graph':
            return graph.executeOp(node, tensorMap, context);
        case 'logical':
            return logical.executeOp(node, tensorMap, context);
        case 'matrices':
            return matrices.executeOp(node, tensorMap, context);
        case 'normalization':
            return normalization.executeOp(node, tensorMap, context);
        case 'reduction':
            return reduction.executeOp(node, tensorMap, context);
        case 'slice_join':
            return sliceJoin.executeOp(node, tensorMap, context);
        case 'transformation':
            return transformation.executeOp(node, tensorMap, context);
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
}
exports.executeOp = executeOp;

},{"./executors/arithmetic_executor":26,"./executors/basic_math_executor":27,"./executors/control_executor":28,"./executors/convolution_executor":29,"./executors/creation_executor":30,"./executors/graph_executor":31,"./executors/image_executor":32,"./executors/logical_executor":33,"./executors/matrices_executor":34,"./executors/normalization_executor":35,"./executors/reduction_executor":36,"./executors/slice_join_executor":37,"./executors/transformation_executor":38}],55:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../data/index");
var utils_1 = require("./executors/utils");
var arithmetic = require("./op_list/arithmetic.json");
var basicMath = require("./op_list/basic_math.json");
var control = require("./op_list/control.json");
var convolution = require("./op_list/convolution.json");
var creation = require("./op_list/creation.json");
var graph = require("./op_list/graph.json");
var image = require("./op_list/image.json");
var logical = require("./op_list/logical.json");
var matrices = require("./op_list/matrices.json");
var normalization = require("./op_list/normalization.json");
var reduction = require("./op_list/reduction.json");
var sliceJoin = require("./op_list/slice_join.json");
var transformation = require("./op_list/transformation.json");
var CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration'];
var OperationMapper = (function () {
    function OperationMapper() {
        var mappersJson = __spread(arithmetic, basicMath, control, convolution, creation, logical, image, graph, matrices, normalization, reduction, sliceJoin, transformation);
        this.opMappers = mappersJson.reduce(function (map, mapper) {
            map[mapper.tfOpName] = mapper;
            return map;
        }, {});
    }
    Object.defineProperty(OperationMapper, "Instance", {
        get: function () {
            return this._instance || (this._instance = new this());
        },
        enumerable: true,
        configurable: true
    });
    OperationMapper.prototype.isControlFlow = function (node) {
        return CONTROL_FLOW_OPS.some(function (op) { return op === node.op; });
    };
    OperationMapper.prototype.transformGraph = function (graph) {
        var _this = this;
        var tfNodes = graph.node;
        var withControlFlow = false;
        var placeholders = [];
        var nodes = tfNodes.reduce(function (map, node) {
            map[node.name] = _this.mapNode(node);
            if (_this.isControlFlow(node))
                withControlFlow = true;
            if (node.op === 'Placeholder')
                placeholders.push(map[node.name]);
            return map;
        }, {});
        var inputs = [];
        var outputs = [];
        Object.keys(nodes).forEach(function (key) {
            var node = nodes[key];
            node.inputNames.forEach(function (name) {
                var _a = __read(utils_1.getNodeNameAndIndex(name), 1), nodeName = _a[0];
                node.inputs.push(nodes[nodeName]);
                nodes[nodeName].children.push(node);
            });
            if (node.inputs.length === 0)
                inputs.push(node);
        });
        Object.keys(nodes).forEach(function (key) {
            var node = nodes[key];
            if (node.children.length === 0)
                outputs.push(node);
        });
        return { nodes: nodes, inputs: inputs, outputs: outputs, placeholders: placeholders, withControlFlow: withControlFlow };
    };
    OperationMapper.prototype.mapNode = function (node) {
        var _this = this;
        var mapper = this.opMappers[node.op];
        if (mapper === undefined) {
            throw new Error('Tensorflow Op is not supported: ' + node.op);
        }
        var newNode = {
            name: node.name,
            op: mapper.dlOpName,
            category: mapper.category,
            inputNames: (node.input ||
                []).map(function (input) { return input.startsWith('^') ? input.substr(1) : input; }),
            inputs: [],
            children: [],
            params: {}
        };
        if (!!mapper.params) {
            newNode.params = mapper.params.reduce(function (map, param) {
                var inputIndex = param.tfInputIndex;
                var inputParamLength = param.tfInputParamLength;
                var type = param.type;
                var value = undefined;
                if (inputIndex === undefined) {
                    switch (param.type) {
                        case 'string':
                            value = _this.getStringParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getStringParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'number':
                            value = _this.getNumberParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getNumberParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'number[]':
                            value = _this.getNumericArrayParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getNumericArrayParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'bool':
                            value = _this.getBoolParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getBoolParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'shape':
                            value = _this.getTensorShapeParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getTensorShapeParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'dtype':
                            value = _this.getDtypeParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getDtypeParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'tensor':
                        case 'tensors':
                            break;
                        default:
                            throw new Error("Unsupported param type: " + param.type + " for op: " + node.op);
                    }
                }
                map[param.dlParamName] = { value: value, inputIndex: inputIndex, type: type, inputParamLength: inputParamLength };
                return map;
            }, {});
        }
        return newNode;
    };
    OperationMapper.prototype.getStringParam = function (attrs, name, def, keepCase) {
        if (keepCase === void 0) { keepCase = false; }
        var param = attrs[name];
        if (param !== undefined) {
            var value = String.fromCharCode.apply(null, param.s);
            return keepCase ? value : value.toLowerCase();
        }
        return def;
    };
    OperationMapper.prototype.getBoolParam = function (attrs, name, def) {
        var param = attrs[name];
        return param ? param.b : def;
    };
    OperationMapper.prototype.getNumberParam = function (attrs, name, def) {
        var param = attrs[name];
        return (param ? ((param.f !== undefined) ? param.f : param.i) : def);
    };
    OperationMapper.prototype.getDtypeParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param && param.type) {
            switch (param.type) {
                case index_1.tensorflow.DataType.DT_FLOAT:
                    return 'float32';
                case index_1.tensorflow.DataType.DT_INT32:
                    return 'int32';
                case index_1.tensorflow.DataType.DT_BOOL:
                    return 'bool';
                default:
                    return def;
            }
        }
        return def;
    };
    OperationMapper.prototype.getTensorShapeParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param && param.shape) {
            return param.shape.dim.map(function (dim) { return dim.size; });
        }
        return def;
    };
    OperationMapper.prototype.getNumericArrayParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param) {
            return (param.list.f && param.list.f.length ? param.list.f :
                param.list.i);
        }
        return def;
    };
    return OperationMapper;
}());
exports.OperationMapper = OperationMapper;

},{"../data/index":20,"./executors/utils":39,"./op_list/arithmetic.json":41,"./op_list/basic_math.json":42,"./op_list/control.json":43,"./op_list/convolution.json":44,"./op_list/creation.json":45,"./op_list/graph.json":46,"./op_list/image.json":47,"./op_list/logical.json":48,"./op_list/matrices.json":49,"./op_list/normalization.json":50,"./op_list/reduction.json":51,"./op_list/slice_join.json":52,"./op_list/transformation.json":53}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.2.1';
exports.version = version;

},{}]},{},[25])(25)
});
